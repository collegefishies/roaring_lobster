// File: hex_counter.v
// Generated by MyHDL 1.0dev
// Date: Tue Jul 19 10:14:58 2016


`timescale 1ns/10ps

module hex_counter (
    clk,
    add,
    sub,
    bin_count,
    hex_count,
    dig_incr,
    time_step,
    reset
);
// NOTE: THE OUTPUTS COME WITH A CLOCK CYCLE DELAY.
// A counter module with two outputs, hex_count, bin_count, each being 
// the 'decimal' in hexadecimal representation, and the other being
// the binary representation. dig_incr is the module that determines by
// what power of ten to increment by, i.e., hex_count.next = hex_count + 
// 10**dig_incr.
// add, and sub are clock enables that determine whether we should add
// or subtract. 

input clk;
input add;
input sub;
output [29:0] bin_count;
reg [29:0] bin_count;
output [35:0] hex_count;
reg [35:0] hex_count;
input [3:0] dig_incr;
input [24:0] time_step;
input reset;

wire [39:0] hex_int;
reg [33:0] bin_int;
reg int_clk;
reg clk_p_time;
reg [31:0] clk_counter;
reg [33:0] rom_2_dout;

reg to_subtract [0:10-1];
reg to_add [0:10-1];
reg [3:0] hex_l [0:10-1];


assign hex_int[40-1:36] = hex_l[9];
assign hex_int[36-1:32] = hex_l[8];
assign hex_int[32-1:28] = hex_l[7];
assign hex_int[28-1:24] = hex_l[6];
assign hex_int[24-1:20] = hex_l[5];
assign hex_int[20-1:16] = hex_l[4];
assign hex_int[16-1:12] = hex_l[3];
assign hex_int[12-1:8] = hex_l[2];
assign hex_int[8-1:4] = hex_l[1];
assign hex_int[4-1:0] = hex_l[0];

// Allow for time_step == 0 
always @(time_step, clk, clk_p_time) begin: HEX_COUNTER_WIRING
    if (((time_step == 0) || (time_step == 1))) begin
        int_clk = clk;
    end
    else begin
        int_clk = clk_p_time;
    end
end

// This is the hexadecimal and binary counter.
// It adds or subtracts only if (add xor sub) is True, to allow for the carry logic
// a new bit of logic is required, namely addlogic, and sublogic. They give out 
// lists of vectors (or integer masks). These are used in the logic below. And work 
// out most of the stuff. One extra if statement is needed to increment the desired 
// byte.
always @(negedge int_clk) begin: HEX_COUNTER_COUNTER
    integer digit;
    if (reset == 1) begin
        bin_int <= 000000000;
        hex_l[0] <= 0;
        hex_l[1] <= 0;
        hex_l[2] <= 0;
        hex_l[3] <= 0;
        hex_l[4] <= 0;
        hex_l[5] <= 0;
        hex_l[6] <= 0;
        hex_l[7] <= 0;
        hex_l[8] <= 0;
        hex_l[9] <= 0;
    end
    else begin
        if ((((bin_int + rom_2_dout) > ((10 ** 10) - 1)) && ((add == 1'b1) && (sub == 1'b0)))) begin
            bin_int <= ((bin_int + rom_2_dout) - (10 ** 10));
        end
        else if (((bin_int < rom_2_dout) && ((sub == 1'b1) && (add == 1'b0)))) begin
            bin_int <= (($signed({1'b0, bin_int}) - $signed({1'b0, rom_2_dout})) + (10 ** 10));
        end
        else begin
            if (((add == 1'b1) && (sub == 1'b0))) begin
                bin_int <= (bin_int + rom_2_dout);
            end
            else if (((sub == 1'b1) && (add == 1'b0))) begin
                bin_int <= (bin_int - rom_2_dout);
            end
            else begin
                bin_int <= bin_int;
            end
        end
        if (((add == 1'b1) && (!sub))) begin
            for (digit=0; digit<10; digit=digit+1) begin
                if ((digit > $signed({1'b0, dig_incr}))) begin
                    if (to_add[digit]) begin
                        if ((hex_l[digit] != 9)) begin
                            hex_l[digit] <= (hex_l[digit] + 1);
                        end
                        else begin
                            hex_l[digit] <= 0;
                        end
                    end
                    else begin
                        hex_l[digit] <= hex_l[digit];
                    end
                end
                else if ((digit == $signed({1'b0, dig_incr}))) begin
                    if ((hex_l[dig_incr] != 9)) begin
                        hex_l[dig_incr] <= (hex_l[dig_incr] + 1);
                    end
                    else begin
                        hex_l[dig_incr] <= 0;
                    end
                end
            end
        end
        else if (((sub == 1'b1) && (!add))) begin
            for (digit=0; digit<10; digit=digit+1) begin
                if ((digit > $signed({1'b0, dig_incr}))) begin
                    if (to_subtract[digit]) begin
                        if ((hex_l[digit] != 0)) begin
                            hex_l[digit] <= (hex_l[digit] - 1);
                        end
                        else begin
                            hex_l[digit] <= 9;
                        end
                    end
                    else begin
                        hex_l[digit] <= hex_l[digit];
                    end
                end
                else if ((digit == $signed({1'b0, dig_incr}))) begin
                    if ((hex_l[dig_incr] != 0)) begin
                        hex_l[dig_incr] <= (hex_l[dig_incr] - 1);
                    end
                    else begin
                        hex_l[dig_incr] <= 9;
                    end
                end
            end
        end
        else begin
            for (digit=0; digit<10; digit=digit+1) begin
                hex_l[digit] <= hex_l[digit];
            end
        end
    end
end


always @(dig_incr) begin: HEX_COUNTER_ROM_2_READ
    case (dig_incr)
        0: rom_2_dout = 1;
        1: rom_2_dout = 10;
        2: rom_2_dout = 100;
        3: rom_2_dout = 1000;
        4: rom_2_dout = 10000;
        5: rom_2_dout = 100000;
        6: rom_2_dout = 1000000;
        7: rom_2_dout = 10000000;
        8: rom_2_dout = 100000000;
        default: rom_2_dout = 1000000000;
    endcase
end

// Drives a pulse with period,
// time_step. 
always @(posedge clk) begin: HEX_COUNTER_CLK_DRIVER
    if (reset == 1) begin
        clk_p_time <= 0;
        clk_counter <= 00000000;
    end
    else begin
        if ((clk_counter == 0)) begin
            clk_p_time <= 1;
            clk_counter <= (clk_counter + 1);
        end
        else if (($signed({1'b0, clk_counter}) >= ($signed({1'b0, time_step}) - 1))) begin
            clk_p_time <= 0;
            clk_counter <= 0;
        end
        else begin
            clk_p_time <= 0;
            clk_counter <= (clk_counter + 1);
        end
    end
end

// Latch values on positive clock edge 
always @(posedge clk) begin: HEX_COUNTER_LATCH_COUNTS
    if (reset == 1) begin
        hex_count <= 000000000;
        bin_count <= 00000000;
    end
    else begin
        hex_count <= hex_int;
        bin_count <= bin_int;
    end
end

// This module determines whether or not to add/sub certain bits,
// in the case of carry over. First we make sure we don't add/sub all
// the bits lower than increment, then we set the increment bit to add/sub,
// and lastly we perform the logic neccessary to determine if bits greater
// than dig_incr need to be added
// 
// It's sensitivity list is long, this is neccessary as to allow the logic 
// to update to_add when any part of to_add changes, as is the case
// when performing carry logic.
always @(dig_incr, add, sub) begin: HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_0_0_INNER
    reg digit;
    digit = 0;
    if ((digit == dig_incr)) begin
        to_add[digit] <= 1;
        to_subtract[digit] <= 1;
    end
    else begin
        to_add[digit] <= 0;
        to_subtract[digit] <= 0;
    end
end


always @(dig_incr, hex_l[0], to_add[0], to_subtract[0], add, sub) begin: HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_1_0_INNER
    if ((1 < dig_incr)) begin
        to_add[1] <= 0;
        to_subtract[1] <= 0;
    end
    else if ((1 == dig_incr)) begin
        to_add[1] <= 1;
        to_subtract[1] <= 1;
    end
    else begin
        to_add[1] <= ((hex_l[(1 - 1)] == 9) && to_add[(1 - 1)]);
        to_subtract[1] <= ((hex_l[(1 - 1)] == 0) && to_subtract[(1 - 1)]);
    end
end


always @(dig_incr, hex_l[1], to_add[1], to_subtract[1], add, sub) begin: HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_2_0_INNER
    if ((2 < dig_incr)) begin
        to_add[2] <= 0;
        to_subtract[2] <= 0;
    end
    else if ((2 == dig_incr)) begin
        to_add[2] <= 1;
        to_subtract[2] <= 1;
    end
    else begin
        to_add[2] <= ((hex_l[(2 - 1)] == 9) && to_add[(2 - 1)]);
        to_subtract[2] <= ((hex_l[(2 - 1)] == 0) && to_subtract[(2 - 1)]);
    end
end


always @(dig_incr, hex_l[2], to_add[2], to_subtract[2], add, sub) begin: HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_3_0_INNER
    if ((3 < dig_incr)) begin
        to_add[3] <= 0;
        to_subtract[3] <= 0;
    end
    else if ((3 == dig_incr)) begin
        to_add[3] <= 1;
        to_subtract[3] <= 1;
    end
    else begin
        to_add[3] <= ((hex_l[(3 - 1)] == 9) && to_add[(3 - 1)]);
        to_subtract[3] <= ((hex_l[(3 - 1)] == 0) && to_subtract[(3 - 1)]);
    end
end


always @(dig_incr, hex_l[3], to_add[3], to_subtract[3], add, sub) begin: HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_4_0_INNER
    if ((4 < dig_incr)) begin
        to_add[4] <= 0;
        to_subtract[4] <= 0;
    end
    else if ((4 == dig_incr)) begin
        to_add[4] <= 1;
        to_subtract[4] <= 1;
    end
    else begin
        to_add[4] <= ((hex_l[(4 - 1)] == 9) && to_add[(4 - 1)]);
        to_subtract[4] <= ((hex_l[(4 - 1)] == 0) && to_subtract[(4 - 1)]);
    end
end


always @(dig_incr, hex_l[4], to_add[4], to_subtract[4], add, sub) begin: HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_5_0_INNER
    if ((5 < dig_incr)) begin
        to_add[5] <= 0;
        to_subtract[5] <= 0;
    end
    else if ((5 == dig_incr)) begin
        to_add[5] <= 1;
        to_subtract[5] <= 1;
    end
    else begin
        to_add[5] <= ((hex_l[(5 - 1)] == 9) && to_add[(5 - 1)]);
        to_subtract[5] <= ((hex_l[(5 - 1)] == 0) && to_subtract[(5 - 1)]);
    end
end


always @(dig_incr, hex_l[5], to_add[5], to_subtract[5], add, sub) begin: HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_6_0_INNER
    if ((6 < dig_incr)) begin
        to_add[6] <= 0;
        to_subtract[6] <= 0;
    end
    else if ((6 == dig_incr)) begin
        to_add[6] <= 1;
        to_subtract[6] <= 1;
    end
    else begin
        to_add[6] <= ((hex_l[(6 - 1)] == 9) && to_add[(6 - 1)]);
        to_subtract[6] <= ((hex_l[(6 - 1)] == 0) && to_subtract[(6 - 1)]);
    end
end


always @(dig_incr, hex_l[6], to_add[6], to_subtract[6], add, sub) begin: HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_7_0_INNER
    if ((7 < dig_incr)) begin
        to_add[7] <= 0;
        to_subtract[7] <= 0;
    end
    else if ((7 == dig_incr)) begin
        to_add[7] <= 1;
        to_subtract[7] <= 1;
    end
    else begin
        to_add[7] <= ((hex_l[(7 - 1)] == 9) && to_add[(7 - 1)]);
        to_subtract[7] <= ((hex_l[(7 - 1)] == 0) && to_subtract[(7 - 1)]);
    end
end


always @(dig_incr, hex_l[7], to_add[7], to_subtract[7], add, sub) begin: HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_8_0_INNER
    if ((8 < dig_incr)) begin
        to_add[8] <= 0;
        to_subtract[8] <= 0;
    end
    else if ((8 == dig_incr)) begin
        to_add[8] <= 1;
        to_subtract[8] <= 1;
    end
    else begin
        to_add[8] <= ((hex_l[(8 - 1)] == 9) && to_add[(8 - 1)]);
        to_subtract[8] <= ((hex_l[(8 - 1)] == 0) && to_subtract[(8 - 1)]);
    end
end


always @(dig_incr, hex_l[8], to_add[8], to_subtract[8], add, sub) begin: HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_9_0_INNER
    if ((9 < dig_incr)) begin
        to_add[9] <= 0;
        to_subtract[9] <= 0;
    end
    else if ((9 == dig_incr)) begin
        to_add[9] <= 1;
        to_subtract[9] <= 1;
    end
    else begin
        to_add[9] <= ((hex_l[(9 - 1)] == 9) && to_add[(9 - 1)]);
        to_subtract[9] <= ((hex_l[(9 - 1)] == 0) && to_subtract[(9 - 1)]);
    end
end


initial begin: HEX_COUNTER_SET_INIT
    integer i;
    # 1;
    for (i=0; i<10; i=i+1) begin
        to_subtract[i] <= 0;
        to_add[i] <= 0;
    end
end

endmodule
