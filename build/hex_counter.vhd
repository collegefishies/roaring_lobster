-- File: hex_counter.vhd
-- Generated by MyHDL 1.0dev
-- Date: Tue Jul 19 10:14:58 2016


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_10.all;

entity hex_counter is
    port (
        clk: in std_logic;
        add: in std_logic;
        sub: in std_logic;
        bin_count: out unsigned(29 downto 0);
        hex_count: out unsigned(35 downto 0);
        dig_incr: in unsigned(3 downto 0);
        time_step: in unsigned(24 downto 0);
        reset: in std_logic
    );
end entity hex_counter;
-- NOTE: THE OUTPUTS COME WITH A CLOCK CYCLE DELAY.
-- A counter module with two outputs, hex_count, bin_count, each being 
-- the 'decimal' in hexadecimal representation, and the other being
-- the binary representation. dig_incr is the module that determines by
-- what power of ten to increment by, i.e., hex_count.next = hex_count + 
-- 10**dig_incr.
-- add, and sub are clock enables that determine whether we should add
-- or subtract. 

architecture MyHDL of hex_counter is



signal hex_int: unsigned(39 downto 0);
signal bin_int: unsigned(33 downto 0);
signal int_clk: std_logic;
signal clk_p_time: std_logic;
signal clk_counter: unsigned(31 downto 0);
signal rom_3_dout: unsigned(33 downto 0);
type t_array_to_subtract is array(0 to 10-1) of std_logic;
signal to_subtract: t_array_to_subtract;
type t_array_to_add is array(0 to 10-1) of std_logic;
signal to_add: t_array_to_add;
type t_array_hex_l is array(0 to 10-1) of unsigned(3 downto 0);
signal hex_l: t_array_hex_l;

begin



hex_int(40-1 downto 36) <= hex_l(9);
hex_int(36-1 downto 32) <= hex_l(8);
hex_int(32-1 downto 28) <= hex_l(7);
hex_int(28-1 downto 24) <= hex_l(6);
hex_int(24-1 downto 20) <= hex_l(5);
hex_int(20-1 downto 16) <= hex_l(4);
hex_int(16-1 downto 12) <= hex_l(3);
hex_int(12-1 downto 8) <= hex_l(2);
hex_int(8-1 downto 4) <= hex_l(1);
hex_int(4-1 downto 0) <= hex_l(0);

-- Allow for time_step == 0 
HEX_COUNTER_WIRING: process (time_step, clk, clk_p_time) is
begin
    if ((time_step = 0) or (time_step = 1)) then
        int_clk <= clk;
    else
        int_clk <= clk_p_time;
    end if;
end process HEX_COUNTER_WIRING;

-- This is the hexadecimal and binary counter.
-- It adds or subtracts only if (add xor sub) is True, to allow for the carry logic
-- a new bit of logic is required, namely addlogic, and sublogic. They give out 
-- lists of vectors (or integer masks). These are used in the logic below. And work 
-- out most of the stuff. One extra if statement is needed to increment the desired 
-- byte.
HEX_COUNTER_COUNTER: process (int_clk) is
begin
    if falling_edge(int_clk) then
        if (reset = '1') then
            bin_int <= to_unsigned(000000000, 34);
            hex_l(0) <= to_unsigned(0, 4);
            hex_l(1) <= to_unsigned(0, 4);
            hex_l(2) <= to_unsigned(0, 4);
            hex_l(3) <= to_unsigned(0, 4);
            hex_l(4) <= to_unsigned(0, 4);
            hex_l(5) <= to_unsigned(0, 4);
            hex_l(6) <= to_unsigned(0, 4);
            hex_l(7) <= to_unsigned(0, 4);
            hex_l(8) <= to_unsigned(0, 4);
            hex_l(9) <= to_unsigned(0, 4);
        else
            if ((signed(resize(bin_int, 35) + rom_3_dout) > ((10 ** 10) - 1)) and ((add = '1') and (sub = '0'))) then
                bin_int <= resize(unsigned(signed(resize(bin_int, 35) + rom_3_dout) - (10 ** 10)), 34);
            elsif ((bin_int < rom_3_dout) and ((sub = '1') and (add = '0'))) then
                bin_int <= resize(unsigned((signed(resize(bin_int, 35)) - signed(resize(rom_3_dout, 35))) + (10 ** 10)), 34);
            else
                if ((add = '1') and (sub = '0')) then
                    bin_int <= (bin_int + rom_3_dout);
                elsif ((sub = '1') and (add = '0')) then
                    bin_int <= (bin_int - rom_3_dout);
                else
                    bin_int <= bin_int;
                end if;
            end if;
            if ((add = '1') and (not bool(sub))) then
                for digit in 0 to 10-1 loop
                    if (digit > signed(resize(dig_incr, 5))) then
                        if bool(to_add(digit)) then
                            if (hex_l(digit) /= 9) then
                                hex_l(digit) <= (hex_l(digit) + 1);
                            else
                                hex_l(digit) <= to_unsigned(0, 4);
                            end if;
                        else
                            hex_l(digit) <= hex_l(digit);
                        end if;
                    elsif (digit = signed(resize(dig_incr, 5))) then
                        if (hex_l(to_integer(dig_incr)) /= 9) then
                            hex_l(to_integer(dig_incr)) <= (hex_l(to_integer(dig_incr)) + 1);
                        else
                            hex_l(to_integer(dig_incr)) <= to_unsigned(0, 4);
                        end if;
                    end if;
                end loop;
            elsif ((sub = '1') and (not bool(add))) then
                for digit in 0 to 10-1 loop
                    if (digit > signed(resize(dig_incr, 5))) then
                        if bool(to_subtract(digit)) then
                            if (hex_l(digit) /= 0) then
                                hex_l(digit) <= (hex_l(digit) - 1);
                            else
                                hex_l(digit) <= to_unsigned(9, 4);
                            end if;
                        else
                            hex_l(digit) <= hex_l(digit);
                        end if;
                    elsif (digit = signed(resize(dig_incr, 5))) then
                        if (hex_l(to_integer(dig_incr)) /= 0) then
                            hex_l(to_integer(dig_incr)) <= (hex_l(to_integer(dig_incr)) - 1);
                        else
                            hex_l(to_integer(dig_incr)) <= to_unsigned(9, 4);
                        end if;
                    end if;
                end loop;
            else
                for digit in 0 to 10-1 loop
                    hex_l(digit) <= hex_l(digit);
                end loop;
            end if;
        end if;
    end if;
end process HEX_COUNTER_COUNTER;


HEX_COUNTER_ROM_3_READ: process (dig_incr) is
begin
    case to_integer(dig_incr) is
        when 0 => rom_3_dout <= "0000000000000000000000000000000001";
        when 1 => rom_3_dout <= "0000000000000000000000000000001010";
        when 2 => rom_3_dout <= "0000000000000000000000000001100100";
        when 3 => rom_3_dout <= "0000000000000000000000001111101000";
        when 4 => rom_3_dout <= "0000000000000000000010011100010000";
        when 5 => rom_3_dout <= "0000000000000000011000011010100000";
        when 6 => rom_3_dout <= "0000000000000011110100001001000000";
        when 7 => rom_3_dout <= "0000000000100110001001011010000000";
        when 8 => rom_3_dout <= "0000000101111101011110000100000000";
        when others => rom_3_dout <= "0000111011100110101100101000000000";
    end case;
end process HEX_COUNTER_ROM_3_READ;

-- Drives a pulse with period,
-- time_step. 
HEX_COUNTER_CLK_DRIVER: process (clk) is
begin
    if rising_edge(clk) then
        if (reset = '1') then
            clk_p_time <= '0';
            clk_counter <= to_unsigned(00000000, 32);
        else
            if (clk_counter = 0) then
                clk_p_time <= '1';
                clk_counter <= (clk_counter + 1);
            elsif (signed(resize(clk_counter, 33)) >= (signed(resize(time_step, 26)) - 1)) then
                clk_p_time <= '0';
                clk_counter <= to_unsigned(0, 32);
            else
                clk_p_time <= '0';
                clk_counter <= (clk_counter + 1);
            end if;
        end if;
    end if;
end process HEX_COUNTER_CLK_DRIVER;

-- Latch values on positive clock edge 
HEX_COUNTER_LATCH_COUNTS: process (clk) is
begin
    if rising_edge(clk) then
        if (reset = '1') then
            hex_count <= to_unsigned(000000000, 36);
            bin_count <= to_unsigned(00000000, 30);
        else
            hex_count <= resize(hex_int, 36);
            bin_count <= resize(bin_int, 30);
        end if;
    end if;
end process HEX_COUNTER_LATCH_COUNTS;

-- This module determines whether or not to add/sub certain bits,
-- in the case of carry over. First we make sure we don't add/sub all
-- the bits lower than increment, then we set the increment bit to add/sub,
-- and lastly we perform the logic neccessary to determine if bits greater
-- than dig_incr need to be added
-- 
-- It's sensitivity list is long, this is neccessary as to allow the logic 
-- to update to_add when any part of to_add changes, as is the case
-- when performing carry logic.
HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_0_0_INNER: process (dig_incr, add, sub) is
    variable digit: std_logic;
begin
    digit := '0';
    if (digit = dig_incr(0)) then
        to_add(to_integer(digit)) <= '1';
        to_subtract(to_integer(digit)) <= '1';
    else
        to_add(to_integer(digit)) <= '0';
        to_subtract(to_integer(digit)) <= '0';
    end if;
end process HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_0_0_INNER;


HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_1_0_INNER: process (dig_incr, hex_l(0), to_add(0), to_subtract(0), add, sub) is
begin
    if (1 < dig_incr) then
        to_add(1) <= '0';
        to_subtract(1) <= '0';
    elsif (1 = dig_incr) then
        to_add(1) <= '1';
        to_subtract(1) <= '1';
    else
        to_add(1) <= stdl((hex_l((1 - 1)) = 9) and bool(to_add((1 - 1))));
        to_subtract(1) <= stdl((hex_l((1 - 1)) = 0) and bool(to_subtract((1 - 1))));
    end if;
end process HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_1_0_INNER;


HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_2_0_INNER: process (dig_incr, hex_l(1), to_add(1), to_subtract(1), add, sub) is
begin
    if (2 < dig_incr) then
        to_add(2) <= '0';
        to_subtract(2) <= '0';
    elsif (2 = dig_incr) then
        to_add(2) <= '1';
        to_subtract(2) <= '1';
    else
        to_add(2) <= stdl((hex_l((2 - 1)) = 9) and bool(to_add((2 - 1))));
        to_subtract(2) <= stdl((hex_l((2 - 1)) = 0) and bool(to_subtract((2 - 1))));
    end if;
end process HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_2_0_INNER;


HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_3_0_INNER: process (dig_incr, hex_l(2), to_add(2), to_subtract(2), add, sub) is
begin
    if (3 < dig_incr) then
        to_add(3) <= '0';
        to_subtract(3) <= '0';
    elsif (3 = dig_incr) then
        to_add(3) <= '1';
        to_subtract(3) <= '1';
    else
        to_add(3) <= stdl((hex_l((3 - 1)) = 9) and bool(to_add((3 - 1))));
        to_subtract(3) <= stdl((hex_l((3 - 1)) = 0) and bool(to_subtract((3 - 1))));
    end if;
end process HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_3_0_INNER;


HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_4_0_INNER: process (dig_incr, hex_l(3), to_add(3), to_subtract(3), add, sub) is
begin
    if (4 < dig_incr) then
        to_add(4) <= '0';
        to_subtract(4) <= '0';
    elsif (4 = dig_incr) then
        to_add(4) <= '1';
        to_subtract(4) <= '1';
    else
        to_add(4) <= stdl((hex_l((4 - 1)) = 9) and bool(to_add((4 - 1))));
        to_subtract(4) <= stdl((hex_l((4 - 1)) = 0) and bool(to_subtract((4 - 1))));
    end if;
end process HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_4_0_INNER;


HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_5_0_INNER: process (dig_incr, hex_l(4), to_add(4), to_subtract(4), add, sub) is
begin
    if (5 < dig_incr) then
        to_add(5) <= '0';
        to_subtract(5) <= '0';
    elsif (5 = dig_incr) then
        to_add(5) <= '1';
        to_subtract(5) <= '1';
    else
        to_add(5) <= stdl((hex_l((5 - 1)) = 9) and bool(to_add((5 - 1))));
        to_subtract(5) <= stdl((hex_l((5 - 1)) = 0) and bool(to_subtract((5 - 1))));
    end if;
end process HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_5_0_INNER;


HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_6_0_INNER: process (dig_incr, hex_l(5), to_add(5), to_subtract(5), add, sub) is
begin
    if (6 < dig_incr) then
        to_add(6) <= '0';
        to_subtract(6) <= '0';
    elsif (6 = dig_incr) then
        to_add(6) <= '1';
        to_subtract(6) <= '1';
    else
        to_add(6) <= stdl((hex_l((6 - 1)) = 9) and bool(to_add((6 - 1))));
        to_subtract(6) <= stdl((hex_l((6 - 1)) = 0) and bool(to_subtract((6 - 1))));
    end if;
end process HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_6_0_INNER;


HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_7_0_INNER: process (dig_incr, hex_l(6), to_add(6), to_subtract(6), add, sub) is
begin
    if (7 < dig_incr) then
        to_add(7) <= '0';
        to_subtract(7) <= '0';
    elsif (7 = dig_incr) then
        to_add(7) <= '1';
        to_subtract(7) <= '1';
    else
        to_add(7) <= stdl((hex_l((7 - 1)) = 9) and bool(to_add((7 - 1))));
        to_subtract(7) <= stdl((hex_l((7 - 1)) = 0) and bool(to_subtract((7 - 1))));
    end if;
end process HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_7_0_INNER;


HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_8_0_INNER: process (dig_incr, hex_l(7), to_add(7), to_subtract(7), add, sub) is
begin
    if (8 < dig_incr) then
        to_add(8) <= '0';
        to_subtract(8) <= '0';
    elsif (8 = dig_incr) then
        to_add(8) <= '1';
        to_subtract(8) <= '1';
    else
        to_add(8) <= stdl((hex_l((8 - 1)) = 9) and bool(to_add((8 - 1))));
        to_subtract(8) <= stdl((hex_l((8 - 1)) = 0) and bool(to_subtract((8 - 1))));
    end if;
end process HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_8_0_INNER;


HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_9_0_INNER: process (dig_incr, hex_l(8), to_add(8), to_subtract(8), add, sub) is
begin
    if (9 < dig_incr) then
        to_add(9) <= '0';
        to_subtract(9) <= '0';
    elsif (9 = dig_incr) then
        to_add(9) <= '1';
        to_subtract(9) <= '1';
    else
        to_add(9) <= stdl((hex_l((9 - 1)) = 9) and bool(to_add((9 - 1))));
        to_subtract(9) <= stdl((hex_l((9 - 1)) = 0) and bool(to_subtract((9 - 1))));
    end if;
end process HEX_COUNTER_ADDSUBLOGIC_0_LOGIC_9_0_INNER;


HEX_COUNTER_SET_INIT: process is
begin
    wait for 1 * 1 ns;
    for i in 0 to 10-1 loop
        to_subtract(i) <= '0';
        to_add(i) <= '0';
    end loop;
    wait;
end process HEX_COUNTER_SET_INIT;

end architecture MyHDL;
