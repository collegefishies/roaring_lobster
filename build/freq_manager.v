// File: freq_manager.v
// Generated by MyHDL 1.0dev
// Date: Tue Jul 19 10:14:59 2016


`timescale 1ns/10ps

module freq_manager (
    clk,
    reset,
    hex_freq,
    sched_length,
    trigger,
    freq_rambus_clk,
    bussedram_4_rambus_we,
    bussedram_4_rambus_waddr,
    freq_rambus_raddr,
    bussedram_4_rambus_din,
    freq_rambus_dout,
    freq_rambus_length,
    fstep_rambus_clk,
    bussedram_5_rambus_we,
    bussedram_5_rambus_waddr,
    fstep_rambus_raddr,
    bussedram_5_rambus_din,
    fstep_rambus_dout,
    fstep_rambus_length,
    tstep_rambus_clk,
    bussedram_6_rambus_we,
    bussedram_6_rambus_waddr,
    tstep_rambus_raddr,
    bussedram_6_rambus_din,
    hex_counter_1_time_step,
    tstep_rambus_length,
    holdt_rambus_clk,
    bussedram_7_rambus_we,
    bussedram_7_rambus_waddr,
    holdt_rambus_raddr,
    bussedram_7_rambus_din,
    holdt_rambus_dout,
    holdt_rambus_length
);


input clk;
input reset;
output [35:0] hex_freq;
wire [35:0] hex_freq;
input [6:0] sched_length;
input trigger;
input freq_rambus_clk;
input bussedram_4_rambus_we;
input [6:0] bussedram_4_rambus_waddr;
output [6:0] freq_rambus_raddr;
wire [6:0] freq_rambus_raddr;
input [31:0] bussedram_4_rambus_din;
output [31:0] freq_rambus_dout;
wire [31:0] freq_rambus_dout;
input [6:0] freq_rambus_length;
input fstep_rambus_clk;
input bussedram_5_rambus_we;
input [6:0] bussedram_5_rambus_waddr;
output [6:0] fstep_rambus_raddr;
wire [6:0] fstep_rambus_raddr;
input [31:0] bussedram_5_rambus_din;
output [31:0] fstep_rambus_dout;
wire [31:0] fstep_rambus_dout;
input [6:0] fstep_rambus_length;
input tstep_rambus_clk;
input bussedram_6_rambus_we;
input [6:0] bussedram_6_rambus_waddr;
output [6:0] tstep_rambus_raddr;
wire [6:0] tstep_rambus_raddr;
input [31:0] bussedram_6_rambus_din;
output [31:0] hex_counter_1_time_step;
wire [31:0] hex_counter_1_time_step;
input [6:0] tstep_rambus_length;
input holdt_rambus_clk;
input bussedram_7_rambus_we;
input [6:0] bussedram_7_rambus_waddr;
output [6:0] holdt_rambus_raddr;
wire [6:0] holdt_rambus_raddr;
input [31:0] bussedram_7_rambus_din;
output [31:0] holdt_rambus_dout;
wire [31:0] holdt_rambus_dout;
input [6:0] holdt_rambus_length;

reg [6:0] sched_addr;
reg add;
reg sub;
reg signed [30:0] bin_count;
reg [35:0] hex_count;
reg [3:0] dig_incr;
reg [3:0] dig_incr_offset;
reg [1:0] state;
reg [31:0] hold_counter;
wire [35:0] hex_counter_1_hex_int;
reg [29:0] hex_counter_1_bin_int;
reg hex_counter_1_int_clk;
reg hex_counter_1_clk_p_time;
reg [31:0] hex_counter_1_clk_counter;
reg [29:0] hex_counter_1_rom_2_dout;
reg [29:0] rom_3_dout;

reg hex_counter_1_to_subtract [0:9-1];
reg hex_counter_1_to_add [0:9-1];
reg [3:0] hex_counter_1_hex_l [0:9-1];
reg [31:0] bussedram_4_mem [0:128-1];
reg [31:0] bussedram_5_mem [0:128-1];
reg [31:0] bussedram_6_mem [0:128-1];
reg [31:0] bussedram_7_mem [0:128-1];


assign hex_counter_1_hex_int[36-1:32] = hex_counter_1_hex_l[8];
assign hex_counter_1_hex_int[32-1:28] = hex_counter_1_hex_l[7];
assign hex_counter_1_hex_int[28-1:24] = hex_counter_1_hex_l[6];
assign hex_counter_1_hex_int[24-1:20] = hex_counter_1_hex_l[5];
assign hex_counter_1_hex_int[20-1:16] = hex_counter_1_hex_l[4];
assign hex_counter_1_hex_int[16-1:12] = hex_counter_1_hex_l[3];
assign hex_counter_1_hex_int[12-1:8] = hex_counter_1_hex_l[2];
assign hex_counter_1_hex_int[8-1:4] = hex_counter_1_hex_l[1];
assign hex_counter_1_hex_int[4-1:0] = hex_counter_1_hex_l[0];

// Allow for time_step == 0 
always @(hex_counter_1_time_step, clk, hex_counter_1_clk_p_time) begin: FREQ_MANAGER_HEX_COUNTER_1_WIRING
    if (((hex_counter_1_time_step == 0) || (hex_counter_1_time_step == 1))) begin
        hex_counter_1_int_clk = clk;
    end
    else begin
        hex_counter_1_int_clk = hex_counter_1_clk_p_time;
    end
end

// This is the hexadecimal and binary counter.
// It adds or subtracts only if (add xor sub) is True, to allow for the carry logic
// a new bit of logic is required, namely addlogic, and sublogic. They give out 
// lists of vectors (or integer masks). These are used in the logic below. And work 
// out most of the stuff. One extra if statement is needed to increment the desired 
// byte.
always @(negedge hex_counter_1_int_clk) begin: FREQ_MANAGER_HEX_COUNTER_1_COUNTER
    integer digit;
    if (reset == 1) begin
        hex_counter_1_bin_int <= 00000000;
        hex_counter_1_hex_l[0] <= 0;
        hex_counter_1_hex_l[1] <= 0;
        hex_counter_1_hex_l[2] <= 0;
        hex_counter_1_hex_l[3] <= 0;
        hex_counter_1_hex_l[4] <= 0;
        hex_counter_1_hex_l[5] <= 0;
        hex_counter_1_hex_l[6] <= 0;
        hex_counter_1_hex_l[7] <= 0;
        hex_counter_1_hex_l[8] <= 0;
    end
    else begin
        if ((((hex_counter_1_bin_int + hex_counter_1_rom_2_dout) > ((10 ** 9) - 1)) && ((add == 1'b1) && (sub == 1'b0)))) begin
            hex_counter_1_bin_int <= ((hex_counter_1_bin_int + hex_counter_1_rom_2_dout) - (10 ** 9));
        end
        else if (((hex_counter_1_bin_int < hex_counter_1_rom_2_dout) && ((sub == 1'b1) && (add == 1'b0)))) begin
            hex_counter_1_bin_int <= (($signed({1'b0, hex_counter_1_bin_int}) - $signed({1'b0, hex_counter_1_rom_2_dout})) + (10 ** 9));
        end
        else begin
            if (((add == 1'b1) && (sub == 1'b0))) begin
                hex_counter_1_bin_int <= (hex_counter_1_bin_int + hex_counter_1_rom_2_dout);
            end
            else if (((sub == 1'b1) && (add == 1'b0))) begin
                hex_counter_1_bin_int <= (hex_counter_1_bin_int - hex_counter_1_rom_2_dout);
            end
            else begin
                hex_counter_1_bin_int <= hex_counter_1_bin_int;
            end
        end
        if (((add == 1'b1) && (!sub))) begin
            for (digit=0; digit<9; digit=digit+1) begin
                if ((digit > $signed({1'b0, dig_incr}))) begin
                    if (hex_counter_1_to_add[digit]) begin
                        if ((hex_counter_1_hex_l[digit] != 9)) begin
                            hex_counter_1_hex_l[digit] <= (hex_counter_1_hex_l[digit] + 1);
                        end
                        else begin
                            hex_counter_1_hex_l[digit] <= 0;
                        end
                    end
                    else begin
                        hex_counter_1_hex_l[digit] <= hex_counter_1_hex_l[digit];
                    end
                end
                else if ((digit == $signed({1'b0, dig_incr}))) begin
                    if ((hex_counter_1_hex_l[dig_incr] != 9)) begin
                        hex_counter_1_hex_l[dig_incr] <= (hex_counter_1_hex_l[dig_incr] + 1);
                    end
                    else begin
                        hex_counter_1_hex_l[dig_incr] <= 0;
                    end
                end
            end
        end
        else if (((sub == 1'b1) && (!add))) begin
            for (digit=0; digit<9; digit=digit+1) begin
                if ((digit > $signed({1'b0, dig_incr}))) begin
                    if (hex_counter_1_to_subtract[digit]) begin
                        if ((hex_counter_1_hex_l[digit] != 0)) begin
                            hex_counter_1_hex_l[digit] <= (hex_counter_1_hex_l[digit] - 1);
                        end
                        else begin
                            hex_counter_1_hex_l[digit] <= 9;
                        end
                    end
                    else begin
                        hex_counter_1_hex_l[digit] <= hex_counter_1_hex_l[digit];
                    end
                end
                else if ((digit == $signed({1'b0, dig_incr}))) begin
                    if ((hex_counter_1_hex_l[dig_incr] != 0)) begin
                        hex_counter_1_hex_l[dig_incr] <= (hex_counter_1_hex_l[dig_incr] - 1);
                    end
                    else begin
                        hex_counter_1_hex_l[dig_incr] <= 9;
                    end
                end
            end
        end
        else begin
            for (digit=0; digit<9; digit=digit+1) begin
                hex_counter_1_hex_l[digit] <= hex_counter_1_hex_l[digit];
            end
        end
    end
end


always @(dig_incr) begin: FREQ_MANAGER_HEX_COUNTER_1_ROM_2_READ
    case (dig_incr)
        0: hex_counter_1_rom_2_dout = 1;
        1: hex_counter_1_rom_2_dout = 10;
        2: hex_counter_1_rom_2_dout = 100;
        3: hex_counter_1_rom_2_dout = 1000;
        4: hex_counter_1_rom_2_dout = 10000;
        5: hex_counter_1_rom_2_dout = 100000;
        6: hex_counter_1_rom_2_dout = 1000000;
        7: hex_counter_1_rom_2_dout = 10000000;
        default: hex_counter_1_rom_2_dout = 100000000;
    endcase
end

// Drives a pulse with period,
// time_step. 
always @(posedge clk) begin: FREQ_MANAGER_HEX_COUNTER_1_CLK_DRIVER
    if (reset == 1) begin
        hex_counter_1_clk_p_time <= 0;
        hex_counter_1_clk_counter <= 00000000;
    end
    else begin
        if ((hex_counter_1_clk_counter == 0)) begin
            hex_counter_1_clk_p_time <= 1;
            hex_counter_1_clk_counter <= (hex_counter_1_clk_counter + 1);
        end
        else if (($signed({1'b0, hex_counter_1_clk_counter}) >= ($signed({1'b0, hex_counter_1_time_step}) - 1))) begin
            hex_counter_1_clk_p_time <= 0;
            hex_counter_1_clk_counter <= 0;
        end
        else begin
            hex_counter_1_clk_p_time <= 0;
            hex_counter_1_clk_counter <= (hex_counter_1_clk_counter + 1);
        end
    end
end

// Latch values on positive clock edge 
always @(posedge clk) begin: FREQ_MANAGER_HEX_COUNTER_1_LATCH_COUNTS
    if (reset == 1) begin
        hex_count <= 000000000;
        bin_count <= 00000000;
    end
    else begin
        hex_count <= hex_counter_1_hex_int;
        bin_count <= hex_counter_1_bin_int;
    end
end

// This module determines whether or not to add/sub certain bits,
// in the case of carry over. First we make sure we don't add/sub all
// the bits lower than increment, then we set the increment bit to add/sub,
// and lastly we perform the logic neccessary to determine if bits greater
// than dig_incr need to be added
// 
// It's sensitivity list is long, this is neccessary as to allow the logic 
// to update to_add when any part of to_add changes, as is the case
// when performing carry logic.
always @(dig_incr, add, sub) begin: FREQ_MANAGER_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_0_0_INNER
    reg digit;
    digit = 0;
    if ((digit == dig_incr)) begin
        hex_counter_1_to_add[digit] <= 1;
        hex_counter_1_to_subtract[digit] <= 1;
    end
    else begin
        hex_counter_1_to_add[digit] <= 0;
        hex_counter_1_to_subtract[digit] <= 0;
    end
end


always @(dig_incr, hex_counter_1_hex_l[0], hex_counter_1_to_add[0], hex_counter_1_to_subtract[0], add, sub) begin: FREQ_MANAGER_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_1_0_INNER
    if ((1 < dig_incr)) begin
        hex_counter_1_to_add[1] <= 0;
        hex_counter_1_to_subtract[1] <= 0;
    end
    else if ((1 == dig_incr)) begin
        hex_counter_1_to_add[1] <= 1;
        hex_counter_1_to_subtract[1] <= 1;
    end
    else begin
        hex_counter_1_to_add[1] <= ((hex_counter_1_hex_l[(1 - 1)] == 9) && hex_counter_1_to_add[(1 - 1)]);
        hex_counter_1_to_subtract[1] <= ((hex_counter_1_hex_l[(1 - 1)] == 0) && hex_counter_1_to_subtract[(1 - 1)]);
    end
end


always @(dig_incr, hex_counter_1_hex_l[1], hex_counter_1_to_add[1], hex_counter_1_to_subtract[1], add, sub) begin: FREQ_MANAGER_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_2_0_INNER
    if ((2 < dig_incr)) begin
        hex_counter_1_to_add[2] <= 0;
        hex_counter_1_to_subtract[2] <= 0;
    end
    else if ((2 == dig_incr)) begin
        hex_counter_1_to_add[2] <= 1;
        hex_counter_1_to_subtract[2] <= 1;
    end
    else begin
        hex_counter_1_to_add[2] <= ((hex_counter_1_hex_l[(2 - 1)] == 9) && hex_counter_1_to_add[(2 - 1)]);
        hex_counter_1_to_subtract[2] <= ((hex_counter_1_hex_l[(2 - 1)] == 0) && hex_counter_1_to_subtract[(2 - 1)]);
    end
end


always @(dig_incr, hex_counter_1_hex_l[2], hex_counter_1_to_add[2], hex_counter_1_to_subtract[2], add, sub) begin: FREQ_MANAGER_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_3_0_INNER
    if ((3 < dig_incr)) begin
        hex_counter_1_to_add[3] <= 0;
        hex_counter_1_to_subtract[3] <= 0;
    end
    else if ((3 == dig_incr)) begin
        hex_counter_1_to_add[3] <= 1;
        hex_counter_1_to_subtract[3] <= 1;
    end
    else begin
        hex_counter_1_to_add[3] <= ((hex_counter_1_hex_l[(3 - 1)] == 9) && hex_counter_1_to_add[(3 - 1)]);
        hex_counter_1_to_subtract[3] <= ((hex_counter_1_hex_l[(3 - 1)] == 0) && hex_counter_1_to_subtract[(3 - 1)]);
    end
end


always @(dig_incr, hex_counter_1_hex_l[3], hex_counter_1_to_add[3], hex_counter_1_to_subtract[3], add, sub) begin: FREQ_MANAGER_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_4_0_INNER
    if ((4 < dig_incr)) begin
        hex_counter_1_to_add[4] <= 0;
        hex_counter_1_to_subtract[4] <= 0;
    end
    else if ((4 == dig_incr)) begin
        hex_counter_1_to_add[4] <= 1;
        hex_counter_1_to_subtract[4] <= 1;
    end
    else begin
        hex_counter_1_to_add[4] <= ((hex_counter_1_hex_l[(4 - 1)] == 9) && hex_counter_1_to_add[(4 - 1)]);
        hex_counter_1_to_subtract[4] <= ((hex_counter_1_hex_l[(4 - 1)] == 0) && hex_counter_1_to_subtract[(4 - 1)]);
    end
end


always @(dig_incr, hex_counter_1_hex_l[4], hex_counter_1_to_add[4], hex_counter_1_to_subtract[4], add, sub) begin: FREQ_MANAGER_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_5_0_INNER
    if ((5 < dig_incr)) begin
        hex_counter_1_to_add[5] <= 0;
        hex_counter_1_to_subtract[5] <= 0;
    end
    else if ((5 == dig_incr)) begin
        hex_counter_1_to_add[5] <= 1;
        hex_counter_1_to_subtract[5] <= 1;
    end
    else begin
        hex_counter_1_to_add[5] <= ((hex_counter_1_hex_l[(5 - 1)] == 9) && hex_counter_1_to_add[(5 - 1)]);
        hex_counter_1_to_subtract[5] <= ((hex_counter_1_hex_l[(5 - 1)] == 0) && hex_counter_1_to_subtract[(5 - 1)]);
    end
end


always @(dig_incr, hex_counter_1_hex_l[5], hex_counter_1_to_add[5], hex_counter_1_to_subtract[5], add, sub) begin: FREQ_MANAGER_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_6_0_INNER
    if ((6 < dig_incr)) begin
        hex_counter_1_to_add[6] <= 0;
        hex_counter_1_to_subtract[6] <= 0;
    end
    else if ((6 == dig_incr)) begin
        hex_counter_1_to_add[6] <= 1;
        hex_counter_1_to_subtract[6] <= 1;
    end
    else begin
        hex_counter_1_to_add[6] <= ((hex_counter_1_hex_l[(6 - 1)] == 9) && hex_counter_1_to_add[(6 - 1)]);
        hex_counter_1_to_subtract[6] <= ((hex_counter_1_hex_l[(6 - 1)] == 0) && hex_counter_1_to_subtract[(6 - 1)]);
    end
end


always @(dig_incr, hex_counter_1_hex_l[6], hex_counter_1_to_add[6], hex_counter_1_to_subtract[6], add, sub) begin: FREQ_MANAGER_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_7_0_INNER
    if ((7 < dig_incr)) begin
        hex_counter_1_to_add[7] <= 0;
        hex_counter_1_to_subtract[7] <= 0;
    end
    else if ((7 == dig_incr)) begin
        hex_counter_1_to_add[7] <= 1;
        hex_counter_1_to_subtract[7] <= 1;
    end
    else begin
        hex_counter_1_to_add[7] <= ((hex_counter_1_hex_l[(7 - 1)] == 9) && hex_counter_1_to_add[(7 - 1)]);
        hex_counter_1_to_subtract[7] <= ((hex_counter_1_hex_l[(7 - 1)] == 0) && hex_counter_1_to_subtract[(7 - 1)]);
    end
end


always @(dig_incr, hex_counter_1_hex_l[7], hex_counter_1_to_add[7], hex_counter_1_to_subtract[7], add, sub) begin: FREQ_MANAGER_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_8_0_INNER
    if ((8 < dig_incr)) begin
        hex_counter_1_to_add[8] <= 0;
        hex_counter_1_to_subtract[8] <= 0;
    end
    else if ((8 == dig_incr)) begin
        hex_counter_1_to_add[8] <= 1;
        hex_counter_1_to_subtract[8] <= 1;
    end
    else begin
        hex_counter_1_to_add[8] <= ((hex_counter_1_hex_l[(8 - 1)] == 9) && hex_counter_1_to_add[(8 - 1)]);
        hex_counter_1_to_subtract[8] <= ((hex_counter_1_hex_l[(8 - 1)] == 0) && hex_counter_1_to_subtract[(8 - 1)]);
    end
end


initial begin: FREQ_MANAGER_HEX_COUNTER_1_SET_INIT
    integer i;
    # 1;
    for (i=0; i<9; i=i+1) begin
        hex_counter_1_to_subtract[i] <= 0;
        hex_counter_1_to_add[i] <= 0;
    end
end

// Connect the ram fstep with 
// a value we subtract for allowing for convergence
always @(fstep_rambus_dout, dig_incr_offset) begin: FREQ_MANAGER_DIGIT_TO_INCREMENT
    if ((fstep_rambus_dout >= dig_incr_offset)) begin
        dig_incr = (fstep_rambus_dout - dig_incr_offset);
    end
    else begin
        dig_incr = 0;
    end
end



assign freq_rambus_raddr = sched_addr;
assign fstep_rambus_raddr = sched_addr;
assign tstep_rambus_raddr = sched_addr;
assign holdt_rambus_raddr = sched_addr;


always @(negedge clk) begin: FREQ_MANAGER_SCHEDULE_STEPPER
    if (reset == 1) begin
        sched_addr <= 00;
        dig_incr_offset <= 0;
        add <= 0;
        sub <= 0;
        hold_counter <= 00000000;
        state <= 2'b00;
    end
    else begin
        case (state)
            2'b00: begin
                sched_addr <= 0;
                dig_incr_offset <= 0;
                add <= 0;
                sub <= 0;
                hold_counter <= 0;
                if ((trigger == 1)) begin
                    state <= 2'b01;
                end
                else begin
                    state <= 2'b00;
                end
            end
            2'b01: begin
                if ((bin_count < $signed({1'b0, freq_rambus_dout}))) begin
                    add <= 1;
                    sub <= 0;
                    if (((sub == 1) && (dig_incr_offset != 9))) begin
                        dig_incr_offset <= (dig_incr_offset + 1);
                    end
                    else begin
                        dig_incr_offset <= dig_incr_offset;
                    end
                end
                else if ((bin_count > $signed({1'b0, freq_rambus_dout}))) begin
                    add <= 0;
                    sub <= 1;
                    if (((add == 1) && (dig_incr_offset != 9))) begin
                        dig_incr_offset <= (dig_incr_offset + 1);
                    end
                    else begin
                        dig_incr_offset <= dig_incr_offset;
                    end
                end
                else begin
                    add <= 0;
                    sub <= 0;
                    state <= 2'b10;
                end
            end
            2'b10: begin
                if ((hold_counter >= holdt_rambus_dout)) begin
                    sched_addr <= (sched_addr + 1);
                    hold_counter <= 0;
                    if (($signed({1'b0, sched_addr}) == ($signed({1'b0, sched_length}) - 1))) begin
                        state <= 2'b11;
                    end
                    else begin
                        state <= 2'b01;
                    end
                end
                else begin
                    hold_counter <= (hold_counter + 1);
                end
            end
            default: begin
                sched_addr <= 0;
                dig_incr_offset <= 0;
                add <= 0;
                sub <= 0;
                hold_counter <= 0;
                state <= 2'b11;
                if ((trigger == 1)) begin
                    state <= 2'b00;
                end
            end
        endcase
    end
end


always @(posedge freq_rambus_clk) begin: FREQ_MANAGER_BUSSEDRAM_4_WRITE
    if (bussedram_4_rambus_we) begin
        bussedram_4_mem[bussedram_4_rambus_waddr] <= bussedram_4_rambus_din;
    end
end



assign freq_rambus_dout = bussedram_4_mem[freq_rambus_raddr];


always @(posedge fstep_rambus_clk) begin: FREQ_MANAGER_BUSSEDRAM_5_WRITE
    if (bussedram_5_rambus_we) begin
        bussedram_5_mem[bussedram_5_rambus_waddr] <= bussedram_5_rambus_din;
    end
end



assign fstep_rambus_dout = bussedram_5_mem[fstep_rambus_raddr];


always @(posedge tstep_rambus_clk) begin: FREQ_MANAGER_BUSSEDRAM_6_WRITE
    if (bussedram_6_rambus_we) begin
        bussedram_6_mem[bussedram_6_rambus_waddr] <= bussedram_6_rambus_din;
    end
end



assign hex_counter_1_time_step = bussedram_6_mem[tstep_rambus_raddr];


always @(posedge holdt_rambus_clk) begin: FREQ_MANAGER_BUSSEDRAM_7_WRITE
    if (bussedram_7_rambus_we) begin
        bussedram_7_mem[bussedram_7_rambus_waddr] <= bussedram_7_rambus_din;
    end
end



assign holdt_rambus_dout = bussedram_7_mem[holdt_rambus_raddr];


always @(dig_incr) begin: FREQ_MANAGER_ROM_3_READ
    case (dig_incr)
        0: rom_3_dout = 1;
        1: rom_3_dout = 10;
        2: rom_3_dout = 100;
        3: rom_3_dout = 1000;
        4: rom_3_dout = 10000;
        5: rom_3_dout = 100000;
        6: rom_3_dout = 1000000;
        7: rom_3_dout = 10000000;
        default: rom_3_dout = 100000000;
    endcase
end



assign hex_freq = hex_count;

endmodule
