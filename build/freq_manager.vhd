-- File: freq_manager.vhd
-- Generated by MyHDL 1.0dev
-- Date: Tue Jul 19 10:15:00 2016


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_10.all;

entity freq_manager is
    port (
        clk: in std_logic;
        reset: in std_logic;
        hex_freq: out unsigned(35 downto 0);
        sched_length: in unsigned(6 downto 0);
        trigger: in std_logic;
        freq_rambus_clk: in std_logic;
        bussedram_8_rambus_we: in std_logic;
        bussedram_8_rambus_waddr: in unsigned(6 downto 0);
        freq_rambus_raddr: inout unsigned(6 downto 0);
        bussedram_8_rambus_din: in unsigned(31 downto 0);
        freq_rambus_dout: inout unsigned(31 downto 0);
        freq_rambus_length: in unsigned(6 downto 0);
        fstep_rambus_clk: in std_logic;
        bussedram_9_rambus_we: in std_logic;
        bussedram_9_rambus_waddr: in unsigned(6 downto 0);
        fstep_rambus_raddr: inout unsigned(6 downto 0);
        bussedram_9_rambus_din: in unsigned(31 downto 0);
        fstep_rambus_dout: inout unsigned(31 downto 0);
        fstep_rambus_length: in unsigned(6 downto 0);
        tstep_rambus_clk: in std_logic;
        bussedram_10_rambus_we: in std_logic;
        bussedram_10_rambus_waddr: in unsigned(6 downto 0);
        tstep_rambus_raddr: inout unsigned(6 downto 0);
        bussedram_10_rambus_din: in unsigned(31 downto 0);
        hex_counter_2_time_step: inout unsigned(31 downto 0);
        tstep_rambus_length: in unsigned(6 downto 0);
        holdt_rambus_clk: in std_logic;
        bussedram_11_rambus_we: in std_logic;
        bussedram_11_rambus_waddr: in unsigned(6 downto 0);
        holdt_rambus_raddr: inout unsigned(6 downto 0);
        bussedram_11_rambus_din: in unsigned(31 downto 0);
        holdt_rambus_dout: inout unsigned(31 downto 0);
        holdt_rambus_length: in unsigned(6 downto 0)
    );
end entity freq_manager;


architecture MyHDL of freq_manager is


type t_enum_sched_1 is (
    START,
    INCREMENTING,
    HOLDING,
    FINISHED
);

signal sched_addr: unsigned(6 downto 0);
signal add: std_logic;
signal sub: std_logic;
signal bin_count: signed (30 downto 0);
signal hex_count: unsigned(35 downto 0);
signal dig_incr: unsigned(3 downto 0);
signal dig_incr_offset: unsigned(3 downto 0);
signal state: t_enum_sched_1;
signal hold_counter: unsigned(31 downto 0);
signal hex_counter_2_hex_int: unsigned(35 downto 0);
signal hex_counter_2_bin_int: unsigned(29 downto 0);
signal hex_counter_2_int_clk: std_logic;
signal hex_counter_2_clk_p_time: std_logic;
signal hex_counter_2_clk_counter: unsigned(31 downto 0);
signal hex_counter_2_rom_4_dout: unsigned(29 downto 0);
signal rom_5_dout: unsigned(29 downto 0);
type t_array_hex_counter_2_to_subtract is array(0 to 9-1) of std_logic;
signal hex_counter_2_to_subtract: t_array_hex_counter_2_to_subtract;
type t_array_hex_counter_2_to_add is array(0 to 9-1) of std_logic;
signal hex_counter_2_to_add: t_array_hex_counter_2_to_add;
type t_array_hex_counter_2_hex_l is array(0 to 9-1) of unsigned(3 downto 0);
signal hex_counter_2_hex_l: t_array_hex_counter_2_hex_l;
type t_array_bussedram_8_mem is array(0 to 128-1) of unsigned(31 downto 0);
signal bussedram_8_mem: t_array_bussedram_8_mem;
type t_array_bussedram_9_mem is array(0 to 128-1) of unsigned(31 downto 0);
signal bussedram_9_mem: t_array_bussedram_9_mem;
type t_array_bussedram_10_mem is array(0 to 128-1) of unsigned(31 downto 0);
signal bussedram_10_mem: t_array_bussedram_10_mem;
type t_array_bussedram_11_mem is array(0 to 128-1) of unsigned(31 downto 0);
signal bussedram_11_mem: t_array_bussedram_11_mem;

begin



hex_counter_2_hex_int(36-1 downto 32) <= hex_counter_2_hex_l(8);
hex_counter_2_hex_int(32-1 downto 28) <= hex_counter_2_hex_l(7);
hex_counter_2_hex_int(28-1 downto 24) <= hex_counter_2_hex_l(6);
hex_counter_2_hex_int(24-1 downto 20) <= hex_counter_2_hex_l(5);
hex_counter_2_hex_int(20-1 downto 16) <= hex_counter_2_hex_l(4);
hex_counter_2_hex_int(16-1 downto 12) <= hex_counter_2_hex_l(3);
hex_counter_2_hex_int(12-1 downto 8) <= hex_counter_2_hex_l(2);
hex_counter_2_hex_int(8-1 downto 4) <= hex_counter_2_hex_l(1);
hex_counter_2_hex_int(4-1 downto 0) <= hex_counter_2_hex_l(0);

-- Allow for time_step == 0 
FREQ_MANAGER_HEX_COUNTER_2_WIRING: process (hex_counter_2_time_step, clk, hex_counter_2_clk_p_time) is
begin
    if ((hex_counter_2_time_step = 0) or (hex_counter_2_time_step = 1)) then
        hex_counter_2_int_clk <= clk;
    else
        hex_counter_2_int_clk <= hex_counter_2_clk_p_time;
    end if;
end process FREQ_MANAGER_HEX_COUNTER_2_WIRING;

-- This is the hexadecimal and binary counter.
-- It adds or subtracts only if (add xor sub) is True, to allow for the carry logic
-- a new bit of logic is required, namely addlogic, and sublogic. They give out 
-- lists of vectors (or integer masks). These are used in the logic below. And work 
-- out most of the stuff. One extra if statement is needed to increment the desired 
-- byte.
FREQ_MANAGER_HEX_COUNTER_2_COUNTER: process (hex_counter_2_int_clk) is
begin
    if falling_edge(hex_counter_2_int_clk) then
        if (reset = '1') then
            hex_counter_2_bin_int <= to_unsigned(00000000, 30);
            hex_counter_2_hex_l(0) <= to_unsigned(0, 4);
            hex_counter_2_hex_l(1) <= to_unsigned(0, 4);
            hex_counter_2_hex_l(2) <= to_unsigned(0, 4);
            hex_counter_2_hex_l(3) <= to_unsigned(0, 4);
            hex_counter_2_hex_l(4) <= to_unsigned(0, 4);
            hex_counter_2_hex_l(5) <= to_unsigned(0, 4);
            hex_counter_2_hex_l(6) <= to_unsigned(0, 4);
            hex_counter_2_hex_l(7) <= to_unsigned(0, 4);
            hex_counter_2_hex_l(8) <= to_unsigned(0, 4);
        else
            if ((signed(resize(hex_counter_2_bin_int, 31) + hex_counter_2_rom_4_dout) > ((10 ** 9) - 1)) and ((add = '1') and (sub = '0'))) then
                hex_counter_2_bin_int <= resize(unsigned(signed(resize(hex_counter_2_bin_int, 31) + hex_counter_2_rom_4_dout) - (10 ** 9)), 30);
            elsif ((hex_counter_2_bin_int < hex_counter_2_rom_4_dout) and ((sub = '1') and (add = '0'))) then
                hex_counter_2_bin_int <= resize(unsigned((signed(resize(hex_counter_2_bin_int, 31)) - signed(resize(hex_counter_2_rom_4_dout, 31))) + (10 ** 9)), 30);
            else
                if ((add = '1') and (sub = '0')) then
                    hex_counter_2_bin_int <= (hex_counter_2_bin_int + hex_counter_2_rom_4_dout);
                elsif ((sub = '1') and (add = '0')) then
                    hex_counter_2_bin_int <= (hex_counter_2_bin_int - hex_counter_2_rom_4_dout);
                else
                    hex_counter_2_bin_int <= hex_counter_2_bin_int;
                end if;
            end if;
            if ((add = '1') and (not bool(sub))) then
                for digit in 0 to 9-1 loop
                    if (digit > signed(resize(dig_incr, 5))) then
                        if bool(hex_counter_2_to_add(digit)) then
                            if (hex_counter_2_hex_l(digit) /= 9) then
                                hex_counter_2_hex_l(digit) <= (hex_counter_2_hex_l(digit) + 1);
                            else
                                hex_counter_2_hex_l(digit) <= to_unsigned(0, 4);
                            end if;
                        else
                            hex_counter_2_hex_l(digit) <= hex_counter_2_hex_l(digit);
                        end if;
                    elsif (digit = signed(resize(dig_incr, 5))) then
                        if (hex_counter_2_hex_l(to_integer(dig_incr)) /= 9) then
                            hex_counter_2_hex_l(to_integer(dig_incr)) <= (hex_counter_2_hex_l(to_integer(dig_incr)) + 1);
                        else
                            hex_counter_2_hex_l(to_integer(dig_incr)) <= to_unsigned(0, 4);
                        end if;
                    end if;
                end loop;
            elsif ((sub = '1') and (not bool(add))) then
                for digit in 0 to 9-1 loop
                    if (digit > signed(resize(dig_incr, 5))) then
                        if bool(hex_counter_2_to_subtract(digit)) then
                            if (hex_counter_2_hex_l(digit) /= 0) then
                                hex_counter_2_hex_l(digit) <= (hex_counter_2_hex_l(digit) - 1);
                            else
                                hex_counter_2_hex_l(digit) <= to_unsigned(9, 4);
                            end if;
                        else
                            hex_counter_2_hex_l(digit) <= hex_counter_2_hex_l(digit);
                        end if;
                    elsif (digit = signed(resize(dig_incr, 5))) then
                        if (hex_counter_2_hex_l(to_integer(dig_incr)) /= 0) then
                            hex_counter_2_hex_l(to_integer(dig_incr)) <= (hex_counter_2_hex_l(to_integer(dig_incr)) - 1);
                        else
                            hex_counter_2_hex_l(to_integer(dig_incr)) <= to_unsigned(9, 4);
                        end if;
                    end if;
                end loop;
            else
                for digit in 0 to 9-1 loop
                    hex_counter_2_hex_l(digit) <= hex_counter_2_hex_l(digit);
                end loop;
            end if;
        end if;
    end if;
end process FREQ_MANAGER_HEX_COUNTER_2_COUNTER;


FREQ_MANAGER_HEX_COUNTER_2_ROM_4_READ: process (dig_incr) is
begin
    case to_integer(dig_incr) is
        when 0 => hex_counter_2_rom_4_dout <= "000000000000000000000000000001";
        when 1 => hex_counter_2_rom_4_dout <= "000000000000000000000000001010";
        when 2 => hex_counter_2_rom_4_dout <= "000000000000000000000001100100";
        when 3 => hex_counter_2_rom_4_dout <= "000000000000000000001111101000";
        when 4 => hex_counter_2_rom_4_dout <= "000000000000000010011100010000";
        when 5 => hex_counter_2_rom_4_dout <= "000000000000011000011010100000";
        when 6 => hex_counter_2_rom_4_dout <= "000000000011110100001001000000";
        when 7 => hex_counter_2_rom_4_dout <= "000000100110001001011010000000";
        when others => hex_counter_2_rom_4_dout <= "000101111101011110000100000000";
    end case;
end process FREQ_MANAGER_HEX_COUNTER_2_ROM_4_READ;

-- Drives a pulse with period,
-- time_step. 
FREQ_MANAGER_HEX_COUNTER_2_CLK_DRIVER: process (clk) is
begin
    if rising_edge(clk) then
        if (reset = '1') then
            hex_counter_2_clk_p_time <= '0';
            hex_counter_2_clk_counter <= to_unsigned(00000000, 32);
        else
            if (hex_counter_2_clk_counter = 0) then
                hex_counter_2_clk_p_time <= '1';
                hex_counter_2_clk_counter <= (hex_counter_2_clk_counter + 1);
            elsif (signed(resize(hex_counter_2_clk_counter, 33)) >= (signed(resize(hex_counter_2_time_step, 33)) - 1)) then
                hex_counter_2_clk_p_time <= '0';
                hex_counter_2_clk_counter <= to_unsigned(0, 32);
            else
                hex_counter_2_clk_p_time <= '0';
                hex_counter_2_clk_counter <= (hex_counter_2_clk_counter + 1);
            end if;
        end if;
    end if;
end process FREQ_MANAGER_HEX_COUNTER_2_CLK_DRIVER;

-- Latch values on positive clock edge 
FREQ_MANAGER_HEX_COUNTER_2_LATCH_COUNTS: process (clk) is
begin
    if rising_edge(clk) then
        if (reset = '1') then
            hex_count <= to_unsigned(000000000, 36);
            bin_count <= to_signed(00000000, 31);
        else
            hex_count <= hex_counter_2_hex_int;
            bin_count <= signed(resize(hex_counter_2_bin_int, 31));
        end if;
    end if;
end process FREQ_MANAGER_HEX_COUNTER_2_LATCH_COUNTS;

-- This module determines whether or not to add/sub certain bits,
-- in the case of carry over. First we make sure we don't add/sub all
-- the bits lower than increment, then we set the increment bit to add/sub,
-- and lastly we perform the logic neccessary to determine if bits greater
-- than dig_incr need to be added
-- 
-- It's sensitivity list is long, this is neccessary as to allow the logic 
-- to update to_add when any part of to_add changes, as is the case
-- when performing carry logic.
FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_0_0_INNER: process (dig_incr, add, sub) is
    variable digit: std_logic;
begin
    digit := '0';
    if (digit = dig_incr(0)) then
        hex_counter_2_to_add(to_integer(digit)) <= '1';
        hex_counter_2_to_subtract(to_integer(digit)) <= '1';
    else
        hex_counter_2_to_add(to_integer(digit)) <= '0';
        hex_counter_2_to_subtract(to_integer(digit)) <= '0';
    end if;
end process FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_0_0_INNER;


FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_1_0_INNER: process (dig_incr, hex_counter_2_hex_l(0), hex_counter_2_to_add(0), hex_counter_2_to_subtract(0), add, sub) is
begin
    if (1 < dig_incr) then
        hex_counter_2_to_add(1) <= '0';
        hex_counter_2_to_subtract(1) <= '0';
    elsif (1 = dig_incr) then
        hex_counter_2_to_add(1) <= '1';
        hex_counter_2_to_subtract(1) <= '1';
    else
        hex_counter_2_to_add(1) <= stdl((hex_counter_2_hex_l((1 - 1)) = 9) and bool(hex_counter_2_to_add((1 - 1))));
        hex_counter_2_to_subtract(1) <= stdl((hex_counter_2_hex_l((1 - 1)) = 0) and bool(hex_counter_2_to_subtract((1 - 1))));
    end if;
end process FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_1_0_INNER;


FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_2_0_INNER: process (dig_incr, hex_counter_2_hex_l(1), hex_counter_2_to_add(1), hex_counter_2_to_subtract(1), add, sub) is
begin
    if (2 < dig_incr) then
        hex_counter_2_to_add(2) <= '0';
        hex_counter_2_to_subtract(2) <= '0';
    elsif (2 = dig_incr) then
        hex_counter_2_to_add(2) <= '1';
        hex_counter_2_to_subtract(2) <= '1';
    else
        hex_counter_2_to_add(2) <= stdl((hex_counter_2_hex_l((2 - 1)) = 9) and bool(hex_counter_2_to_add((2 - 1))));
        hex_counter_2_to_subtract(2) <= stdl((hex_counter_2_hex_l((2 - 1)) = 0) and bool(hex_counter_2_to_subtract((2 - 1))));
    end if;
end process FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_2_0_INNER;


FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_3_0_INNER: process (dig_incr, hex_counter_2_hex_l(2), hex_counter_2_to_add(2), hex_counter_2_to_subtract(2), add, sub) is
begin
    if (3 < dig_incr) then
        hex_counter_2_to_add(3) <= '0';
        hex_counter_2_to_subtract(3) <= '0';
    elsif (3 = dig_incr) then
        hex_counter_2_to_add(3) <= '1';
        hex_counter_2_to_subtract(3) <= '1';
    else
        hex_counter_2_to_add(3) <= stdl((hex_counter_2_hex_l((3 - 1)) = 9) and bool(hex_counter_2_to_add((3 - 1))));
        hex_counter_2_to_subtract(3) <= stdl((hex_counter_2_hex_l((3 - 1)) = 0) and bool(hex_counter_2_to_subtract((3 - 1))));
    end if;
end process FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_3_0_INNER;


FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_4_0_INNER: process (dig_incr, hex_counter_2_hex_l(3), hex_counter_2_to_add(3), hex_counter_2_to_subtract(3), add, sub) is
begin
    if (4 < dig_incr) then
        hex_counter_2_to_add(4) <= '0';
        hex_counter_2_to_subtract(4) <= '0';
    elsif (4 = dig_incr) then
        hex_counter_2_to_add(4) <= '1';
        hex_counter_2_to_subtract(4) <= '1';
    else
        hex_counter_2_to_add(4) <= stdl((hex_counter_2_hex_l((4 - 1)) = 9) and bool(hex_counter_2_to_add((4 - 1))));
        hex_counter_2_to_subtract(4) <= stdl((hex_counter_2_hex_l((4 - 1)) = 0) and bool(hex_counter_2_to_subtract((4 - 1))));
    end if;
end process FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_4_0_INNER;


FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_5_0_INNER: process (dig_incr, hex_counter_2_hex_l(4), hex_counter_2_to_add(4), hex_counter_2_to_subtract(4), add, sub) is
begin
    if (5 < dig_incr) then
        hex_counter_2_to_add(5) <= '0';
        hex_counter_2_to_subtract(5) <= '0';
    elsif (5 = dig_incr) then
        hex_counter_2_to_add(5) <= '1';
        hex_counter_2_to_subtract(5) <= '1';
    else
        hex_counter_2_to_add(5) <= stdl((hex_counter_2_hex_l((5 - 1)) = 9) and bool(hex_counter_2_to_add((5 - 1))));
        hex_counter_2_to_subtract(5) <= stdl((hex_counter_2_hex_l((5 - 1)) = 0) and bool(hex_counter_2_to_subtract((5 - 1))));
    end if;
end process FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_5_0_INNER;


FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_6_0_INNER: process (dig_incr, hex_counter_2_hex_l(5), hex_counter_2_to_add(5), hex_counter_2_to_subtract(5), add, sub) is
begin
    if (6 < dig_incr) then
        hex_counter_2_to_add(6) <= '0';
        hex_counter_2_to_subtract(6) <= '0';
    elsif (6 = dig_incr) then
        hex_counter_2_to_add(6) <= '1';
        hex_counter_2_to_subtract(6) <= '1';
    else
        hex_counter_2_to_add(6) <= stdl((hex_counter_2_hex_l((6 - 1)) = 9) and bool(hex_counter_2_to_add((6 - 1))));
        hex_counter_2_to_subtract(6) <= stdl((hex_counter_2_hex_l((6 - 1)) = 0) and bool(hex_counter_2_to_subtract((6 - 1))));
    end if;
end process FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_6_0_INNER;


FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_7_0_INNER: process (dig_incr, hex_counter_2_hex_l(6), hex_counter_2_to_add(6), hex_counter_2_to_subtract(6), add, sub) is
begin
    if (7 < dig_incr) then
        hex_counter_2_to_add(7) <= '0';
        hex_counter_2_to_subtract(7) <= '0';
    elsif (7 = dig_incr) then
        hex_counter_2_to_add(7) <= '1';
        hex_counter_2_to_subtract(7) <= '1';
    else
        hex_counter_2_to_add(7) <= stdl((hex_counter_2_hex_l((7 - 1)) = 9) and bool(hex_counter_2_to_add((7 - 1))));
        hex_counter_2_to_subtract(7) <= stdl((hex_counter_2_hex_l((7 - 1)) = 0) and bool(hex_counter_2_to_subtract((7 - 1))));
    end if;
end process FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_7_0_INNER;


FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_8_0_INNER: process (dig_incr, hex_counter_2_hex_l(7), hex_counter_2_to_add(7), hex_counter_2_to_subtract(7), add, sub) is
begin
    if (8 < dig_incr) then
        hex_counter_2_to_add(8) <= '0';
        hex_counter_2_to_subtract(8) <= '0';
    elsif (8 = dig_incr) then
        hex_counter_2_to_add(8) <= '1';
        hex_counter_2_to_subtract(8) <= '1';
    else
        hex_counter_2_to_add(8) <= stdl((hex_counter_2_hex_l((8 - 1)) = 9) and bool(hex_counter_2_to_add((8 - 1))));
        hex_counter_2_to_subtract(8) <= stdl((hex_counter_2_hex_l((8 - 1)) = 0) and bool(hex_counter_2_to_subtract((8 - 1))));
    end if;
end process FREQ_MANAGER_HEX_COUNTER_2_ADDSUBLOGIC_0_LOGIC_8_0_INNER;


FREQ_MANAGER_HEX_COUNTER_2_SET_INIT: process is
begin
    wait for 1 * 1 ns;
    for i in 0 to 9-1 loop
        hex_counter_2_to_subtract(i) <= '0';
        hex_counter_2_to_add(i) <= '0';
    end loop;
    wait;
end process FREQ_MANAGER_HEX_COUNTER_2_SET_INIT;

-- Connect the ram fstep with 
-- a value we subtract for allowing for convergence
FREQ_MANAGER_DIGIT_TO_INCREMENT: process (fstep_rambus_dout, dig_incr_offset) is
begin
    if (fstep_rambus_dout >= dig_incr_offset) then
        dig_incr <= resize(fstep_rambus_dout - dig_incr_offset, 4);
    else
        dig_incr <= to_unsigned(0, 4);
    end if;
end process FREQ_MANAGER_DIGIT_TO_INCREMENT;



freq_rambus_raddr <= sched_addr;
fstep_rambus_raddr <= sched_addr;
tstep_rambus_raddr <= sched_addr;
holdt_rambus_raddr <= sched_addr;


FREQ_MANAGER_SCHEDULE_STEPPER: process (clk) is
begin
    if falling_edge(clk) then
        if (reset = '1') then
            sched_addr <= to_unsigned(00, 7);
            dig_incr_offset <= to_unsigned(0, 4);
            add <= '0';
            sub <= '0';
            hold_counter <= to_unsigned(00000000, 32);
            state <= START;
        else
            case state is
                when START =>
                    sched_addr <= to_unsigned(0, 7);
                    dig_incr_offset <= to_unsigned(0, 4);
                    add <= '0';
                    sub <= '0';
                    hold_counter <= to_unsigned(0, 32);
                    if (trigger = '1') then
                        state <= INCREMENTING;
                    else
                        state <= START;
                    end if;
                when INCREMENTING =>
                    if (bin_count < signed(resize(freq_rambus_dout, 33))) then
                        add <= '1';
                        sub <= '0';
                        if ((sub = '1') and (dig_incr_offset /= 9)) then
                            dig_incr_offset <= (dig_incr_offset + 1);
                        else
                            dig_incr_offset <= dig_incr_offset;
                        end if;
                    elsif (bin_count > signed(resize(freq_rambus_dout, 33))) then
                        add <= '0';
                        sub <= '1';
                        if ((add = '1') and (dig_incr_offset /= 9)) then
                            dig_incr_offset <= (dig_incr_offset + 1);
                        else
                            dig_incr_offset <= dig_incr_offset;
                        end if;
                    else
                        add <= '0';
                        sub <= '0';
                        state <= HOLDING;
                    end if;
                when HOLDING =>
                    if (hold_counter >= holdt_rambus_dout) then
                        sched_addr <= (sched_addr + 1);
                        hold_counter <= to_unsigned(0, 32);
                        if (signed(resize(sched_addr, 8)) = (signed(resize(sched_length, 8)) - 1)) then
                            state <= FINISHED;
                        else
                            state <= INCREMENTING;
                        end if;
                    else
                        hold_counter <= (hold_counter + 1);
                    end if;
                when others =>
                    sched_addr <= to_unsigned(0, 7);
                    dig_incr_offset <= to_unsigned(0, 4);
                    add <= '0';
                    sub <= '0';
                    hold_counter <= to_unsigned(0, 32);
                    state <= FINISHED;
                    if (trigger = '1') then
                        state <= START;
                    end if;
            end case;
        end if;
    end if;
end process FREQ_MANAGER_SCHEDULE_STEPPER;


FREQ_MANAGER_BUSSEDRAM_8_WRITE: process (freq_rambus_clk) is
begin
    if rising_edge(freq_rambus_clk) then
        if bool(bussedram_8_rambus_we) then
            bussedram_8_mem(to_integer(bussedram_8_rambus_waddr)) <= bussedram_8_rambus_din;
        end if;
    end if;
end process FREQ_MANAGER_BUSSEDRAM_8_WRITE;



freq_rambus_dout <= bussedram_8_mem(to_integer(freq_rambus_raddr));


FREQ_MANAGER_BUSSEDRAM_9_WRITE: process (fstep_rambus_clk) is
begin
    if rising_edge(fstep_rambus_clk) then
        if bool(bussedram_9_rambus_we) then
            bussedram_9_mem(to_integer(bussedram_9_rambus_waddr)) <= bussedram_9_rambus_din;
        end if;
    end if;
end process FREQ_MANAGER_BUSSEDRAM_9_WRITE;



fstep_rambus_dout <= bussedram_9_mem(to_integer(fstep_rambus_raddr));


FREQ_MANAGER_BUSSEDRAM_10_WRITE: process (tstep_rambus_clk) is
begin
    if rising_edge(tstep_rambus_clk) then
        if bool(bussedram_10_rambus_we) then
            bussedram_10_mem(to_integer(bussedram_10_rambus_waddr)) <= bussedram_10_rambus_din;
        end if;
    end if;
end process FREQ_MANAGER_BUSSEDRAM_10_WRITE;



hex_counter_2_time_step <= bussedram_10_mem(to_integer(tstep_rambus_raddr));


FREQ_MANAGER_BUSSEDRAM_11_WRITE: process (holdt_rambus_clk) is
begin
    if rising_edge(holdt_rambus_clk) then
        if bool(bussedram_11_rambus_we) then
            bussedram_11_mem(to_integer(bussedram_11_rambus_waddr)) <= bussedram_11_rambus_din;
        end if;
    end if;
end process FREQ_MANAGER_BUSSEDRAM_11_WRITE;



holdt_rambus_dout <= bussedram_11_mem(to_integer(holdt_rambus_raddr));


FREQ_MANAGER_ROM_5_READ: process (dig_incr) is
begin
    case to_integer(dig_incr) is
        when 0 => rom_5_dout <= "000000000000000000000000000001";
        when 1 => rom_5_dout <= "000000000000000000000000001010";
        when 2 => rom_5_dout <= "000000000000000000000001100100";
        when 3 => rom_5_dout <= "000000000000000000001111101000";
        when 4 => rom_5_dout <= "000000000000000010011100010000";
        when 5 => rom_5_dout <= "000000000000011000011010100000";
        when 6 => rom_5_dout <= "000000000011110100001001000000";
        when 7 => rom_5_dout <= "000000100110001001011010000000";
        when others => rom_5_dout <= "000101111101011110000100000000";
    end case;
end process FREQ_MANAGER_ROM_5_READ;



hex_freq <= hex_count;

end architecture MyHDL;
