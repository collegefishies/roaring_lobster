// File: with_uart.v
// Generated by MyHDL 1.0dev
// Date: Tue Jul 19 10:29:11 2016


`timescale 1ns/10ps

module with_uart (
    clk,
    amphenol,
    fpga_rx,
    fpga_tx,
    trigger,
    led2,
    reset
);


input clk;
output [49:0] amphenol;
wire [49:0] amphenol;
input fpga_rx;
input fpga_tx;
input trigger;
output [8:0] led2;
reg [8:0] led2;
input reset;

wire [35:0] hex_freq;
reg [6:0] sched_len;
wire [8:0] led2_i;
wire notclock;
reg all_data_received;
wire trigger_mask;
reg [7:0] whichram;
wire [31:0] biggestblock;
reg [1:0] state;
reg [7:0] rx_data;
wire drdy;
reg [7:0] freq_rambus_addr;
reg [7:0] fstep_rambus_addr;
reg [7:0] tstep_rambus_addr;
reg [7:0] hold_rambus_addr;
reg freq_man_reset;
reg [6:0] freq_rambus_length;
reg [6:0] fstep_rambus_length;
reg [6:0] tstep_rambus_length;
reg [6:0] hold_rambus_length;
wire [31:0] freq_rambus_din;
wire [31:0] fstep_rambus_din;
wire [31:0] tstep_rambus_din;
wire [31:0] hold_rambus_din;
wire freq_rambus_clk;
wire fstep_rambus_clk;
wire tstep_rambus_clk;
wire hold_rambus_clk;
wire [6:0] freq_rambus_waddr;
wire [6:0] fstep_rambus_waddr;
wire [6:0] tstep_rambus_waddr;
wire [6:0] hold_rambus_waddr;
reg [6:0] freq_manager_1_sched_addr;
reg freq_manager_1_add;
reg freq_manager_1_sub;
reg signed [30:0] freq_manager_1_bin_count;
reg [35:0] freq_manager_1_hex_count;
reg [3:0] freq_manager_1_dig_incr;
reg [3:0] freq_manager_1_dig_incr_offset;
wire [31:0] freq_manager_1_fstep_rambus_dout;
wire [6:0] freq_manager_1_freq_rambus_raddr;
wire [6:0] freq_manager_1_fstep_rambus_raddr;
wire [6:0] freq_manager_1_tstep_rambus_raddr;
wire [6:0] freq_manager_1_holdt_rambus_raddr;
reg [1:0] freq_manager_1_state;
reg [31:0] freq_manager_1_hold_counter;
wire [31:0] freq_manager_1_freq_rambus_dout;
wire [31:0] freq_manager_1_holdt_rambus_dout;
wire [31:0] freq_manager_1_hex_counter_1_time_step;
wire [35:0] freq_manager_1_hex_counter_1_hex_int;
reg [29:0] freq_manager_1_hex_counter_1_bin_int;
reg freq_manager_1_hex_counter_1_int_clk;
reg freq_manager_1_hex_counter_1_clk_p_time;
reg [31:0] freq_manager_1_hex_counter_1_clk_counter;
reg [29:0] freq_manager_1_hex_counter_1_rom_2_dout;
reg freq_manager_1_bussedram_4_rambus_we;
reg freq_manager_1_bussedram_5_rambus_we;
reg freq_manager_1_bussedram_6_rambus_we;
reg freq_manager_1_bussedram_7_rambus_we;
reg [29:0] freq_manager_1_rom_3_dout;
wire uart_1_baud;
wire uart_1_slowbaud;
wire uart_1_slowbaud_rst;
reg uart_1_started;
reg [2:0] uart_1_bauds_held_down;
reg [4:0] uart_1_bits_received;
wire uart_1_drdy_int;
reg uart_1_latch_en;
reg uart_1_drdy1;
reg uart_1_drdy2;
wire [7:0] uart_1_rx_data_int;
reg uart_1_clkdiv_2_clk_new;
reg [7:0] uart_1_clkdiv_2_counter;
reg uart_1_clkdiv_3_clk_new;
reg [2:0] uart_1_clkdiv_3_counter;
wire [7:0] uart_1_shiftreg_1_par_int;
reg uart_1_shiftreg_1_clk_int;
reg comms_arbiter_0_delayed_reset1;
reg comms_arbiter_0_delayed_reset2;
reg [7:0] comms_arbiter_0_latch_counter;
reg comms_arbiter_0_drdy_turnedon;
reg comms_arbiter_0_drdy_old;
wire [49:0] pts_controller_1_amphenol_int;

reg led2_l [0:9-1];
reg biggestblock_l [0:32-1];
reg freq_manager_1_hex_counter_1_to_subtract [0:9-1];
reg freq_manager_1_hex_counter_1_to_add [0:9-1];
reg [3:0] freq_manager_1_hex_counter_1_hex_l [0:9-1];
reg [31:0] freq_manager_1_bussedram_4_mem [0:128-1];
reg [31:0] freq_manager_1_bussedram_5_mem [0:128-1];
reg [31:0] freq_manager_1_bussedram_6_mem [0:128-1];
reg [31:0] freq_manager_1_bussedram_7_mem [0:128-1];
reg uart_1_shiftreg_1_latches [0:8-1];
wire pts_controller_1_amphenol_l [0:50-1];


assign led2_i[8] = led2_l[8];
assign led2_i[7] = led2_l[7];
assign led2_i[6] = led2_l[6];
assign led2_i[5] = led2_l[5];
assign led2_i[4] = led2_l[4];
assign led2_i[3] = led2_l[3];
assign led2_i[2] = led2_l[2];
assign led2_i[1] = led2_l[1];
assign led2_i[0] = led2_l[0];
assign biggestblock[31] = biggestblock_l[31];
assign biggestblock[30] = biggestblock_l[30];
assign biggestblock[29] = biggestblock_l[29];
assign biggestblock[28] = biggestblock_l[28];
assign biggestblock[27] = biggestblock_l[27];
assign biggestblock[26] = biggestblock_l[26];
assign biggestblock[25] = biggestblock_l[25];
assign biggestblock[24] = biggestblock_l[24];
assign biggestblock[23] = biggestblock_l[23];
assign biggestblock[22] = biggestblock_l[22];
assign biggestblock[21] = biggestblock_l[21];
assign biggestblock[20] = biggestblock_l[20];
assign biggestblock[19] = biggestblock_l[19];
assign biggestblock[18] = biggestblock_l[18];
assign biggestblock[17] = biggestblock_l[17];
assign biggestblock[16] = biggestblock_l[16];
assign biggestblock[15] = biggestblock_l[15];
assign biggestblock[14] = biggestblock_l[14];
assign biggestblock[13] = biggestblock_l[13];
assign biggestblock[12] = biggestblock_l[12];
assign biggestblock[11] = biggestblock_l[11];
assign biggestblock[10] = biggestblock_l[10];
assign biggestblock[9] = biggestblock_l[9];
assign biggestblock[8] = biggestblock_l[8];
assign biggestblock[7] = biggestblock_l[7];
assign biggestblock[6] = biggestblock_l[6];
assign biggestblock[5] = biggestblock_l[5];
assign biggestblock[4] = biggestblock_l[4];
assign biggestblock[3] = biggestblock_l[3];
assign biggestblock[2] = biggestblock_l[2];
assign biggestblock[1] = biggestblock_l[1];
assign biggestblock[0] = biggestblock_l[0];
assign freq_manager_1_hex_counter_1_hex_int[36-1:32] = freq_manager_1_hex_counter_1_hex_l[8];
assign freq_manager_1_hex_counter_1_hex_int[32-1:28] = freq_manager_1_hex_counter_1_hex_l[7];
assign freq_manager_1_hex_counter_1_hex_int[28-1:24] = freq_manager_1_hex_counter_1_hex_l[6];
assign freq_manager_1_hex_counter_1_hex_int[24-1:20] = freq_manager_1_hex_counter_1_hex_l[5];
assign freq_manager_1_hex_counter_1_hex_int[20-1:16] = freq_manager_1_hex_counter_1_hex_l[4];
assign freq_manager_1_hex_counter_1_hex_int[16-1:12] = freq_manager_1_hex_counter_1_hex_l[3];
assign freq_manager_1_hex_counter_1_hex_int[12-1:8] = freq_manager_1_hex_counter_1_hex_l[2];
assign freq_manager_1_hex_counter_1_hex_int[8-1:4] = freq_manager_1_hex_counter_1_hex_l[1];
assign freq_manager_1_hex_counter_1_hex_int[4-1:0] = freq_manager_1_hex_counter_1_hex_l[0];
assign uart_1_shiftreg_1_par_int[7] = uart_1_shiftreg_1_latches[0];
assign uart_1_shiftreg_1_par_int[6] = uart_1_shiftreg_1_latches[1];
assign uart_1_shiftreg_1_par_int[5] = uart_1_shiftreg_1_latches[2];
assign uart_1_shiftreg_1_par_int[4] = uart_1_shiftreg_1_latches[3];
assign uart_1_shiftreg_1_par_int[3] = uart_1_shiftreg_1_latches[4];
assign uart_1_shiftreg_1_par_int[2] = uart_1_shiftreg_1_latches[5];
assign uart_1_shiftreg_1_par_int[1] = uart_1_shiftreg_1_latches[6];
assign uart_1_shiftreg_1_par_int[0] = uart_1_shiftreg_1_latches[7];
assign pts_controller_1_amphenol_int[49] = pts_controller_1_amphenol_l[49];
assign pts_controller_1_amphenol_int[48] = pts_controller_1_amphenol_l[48];
assign pts_controller_1_amphenol_int[47] = pts_controller_1_amphenol_l[47];
assign pts_controller_1_amphenol_int[46] = pts_controller_1_amphenol_l[46];
assign pts_controller_1_amphenol_int[45] = pts_controller_1_amphenol_l[45];
assign pts_controller_1_amphenol_int[44] = pts_controller_1_amphenol_l[44];
assign pts_controller_1_amphenol_int[43] = pts_controller_1_amphenol_l[43];
assign pts_controller_1_amphenol_int[42] = pts_controller_1_amphenol_l[42];
assign pts_controller_1_amphenol_int[41] = pts_controller_1_amphenol_l[41];
assign pts_controller_1_amphenol_int[40] = pts_controller_1_amphenol_l[40];
assign pts_controller_1_amphenol_int[39] = pts_controller_1_amphenol_l[39];
assign pts_controller_1_amphenol_int[38] = pts_controller_1_amphenol_l[38];
assign pts_controller_1_amphenol_int[37] = pts_controller_1_amphenol_l[37];
assign pts_controller_1_amphenol_int[36] = pts_controller_1_amphenol_l[36];
assign pts_controller_1_amphenol_int[35] = pts_controller_1_amphenol_l[35];
assign pts_controller_1_amphenol_int[34] = pts_controller_1_amphenol_l[34];
assign pts_controller_1_amphenol_int[33] = pts_controller_1_amphenol_l[33];
assign pts_controller_1_amphenol_int[32] = pts_controller_1_amphenol_l[32];
assign pts_controller_1_amphenol_int[31] = pts_controller_1_amphenol_l[31];
assign pts_controller_1_amphenol_int[30] = pts_controller_1_amphenol_l[30];
assign pts_controller_1_amphenol_int[29] = pts_controller_1_amphenol_l[29];
assign pts_controller_1_amphenol_int[28] = pts_controller_1_amphenol_l[28];
assign pts_controller_1_amphenol_int[27] = pts_controller_1_amphenol_l[27];
assign pts_controller_1_amphenol_int[26] = pts_controller_1_amphenol_l[26];
assign pts_controller_1_amphenol_int[25] = pts_controller_1_amphenol_l[25];
assign pts_controller_1_amphenol_int[24] = pts_controller_1_amphenol_l[24];
assign pts_controller_1_amphenol_int[23] = pts_controller_1_amphenol_l[23];
assign pts_controller_1_amphenol_int[22] = pts_controller_1_amphenol_l[22];
assign pts_controller_1_amphenol_int[21] = pts_controller_1_amphenol_l[21];
assign pts_controller_1_amphenol_int[20] = pts_controller_1_amphenol_l[20];
assign pts_controller_1_amphenol_int[19] = pts_controller_1_amphenol_l[19];
assign pts_controller_1_amphenol_int[18] = pts_controller_1_amphenol_l[18];
assign pts_controller_1_amphenol_int[17] = pts_controller_1_amphenol_l[17];
assign pts_controller_1_amphenol_int[16] = pts_controller_1_amphenol_l[16];
assign pts_controller_1_amphenol_int[15] = pts_controller_1_amphenol_l[15];
assign pts_controller_1_amphenol_int[14] = pts_controller_1_amphenol_l[14];
assign pts_controller_1_amphenol_int[13] = pts_controller_1_amphenol_l[13];
assign pts_controller_1_amphenol_int[12] = pts_controller_1_amphenol_l[12];
assign pts_controller_1_amphenol_int[11] = pts_controller_1_amphenol_l[11];
assign pts_controller_1_amphenol_int[10] = pts_controller_1_amphenol_l[10];
assign pts_controller_1_amphenol_int[9] = pts_controller_1_amphenol_l[9];
assign pts_controller_1_amphenol_int[8] = pts_controller_1_amphenol_l[8];
assign pts_controller_1_amphenol_int[7] = pts_controller_1_amphenol_l[7];
assign pts_controller_1_amphenol_int[6] = pts_controller_1_amphenol_l[6];
assign pts_controller_1_amphenol_int[5] = pts_controller_1_amphenol_l[5];
assign pts_controller_1_amphenol_int[4] = pts_controller_1_amphenol_l[4];
assign pts_controller_1_amphenol_int[3] = pts_controller_1_amphenol_l[3];
assign pts_controller_1_amphenol_int[2] = pts_controller_1_amphenol_l[2];
assign pts_controller_1_amphenol_int[1] = pts_controller_1_amphenol_l[1];
assign pts_controller_1_amphenol_int[0] = pts_controller_1_amphenol_l[0];

// Allow for time_step == 0 
always @(freq_manager_1_hex_counter_1_time_step, clk, freq_manager_1_hex_counter_1_clk_p_time) begin: WITH_UART_FREQ_MANAGER_1_HEX_COUNTER_1_WIRING
    if (((freq_manager_1_hex_counter_1_time_step == 0) || (freq_manager_1_hex_counter_1_time_step == 1))) begin
        freq_manager_1_hex_counter_1_int_clk = clk;
    end
    else begin
        freq_manager_1_hex_counter_1_int_clk = freq_manager_1_hex_counter_1_clk_p_time;
    end
end

// This is the hexadecimal and binary counter.
// It adds or subtracts only if (add xor sub) is True, to allow for the carry logic
// a new bit of logic is required, namely addlogic, and sublogic. They give out 
// lists of vectors (or integer masks). These are used in the logic below. And work 
// out most of the stuff. One extra if statement is needed to increment the desired 
// byte.
always @(negedge freq_manager_1_hex_counter_1_int_clk) begin: WITH_UART_FREQ_MANAGER_1_HEX_COUNTER_1_COUNTER
    integer digit;
    if (freq_man_reset == 1) begin
        freq_manager_1_hex_counter_1_bin_int <= 00000000;
        freq_manager_1_hex_counter_1_hex_l[0] <= 0;
        freq_manager_1_hex_counter_1_hex_l[1] <= 0;
        freq_manager_1_hex_counter_1_hex_l[2] <= 0;
        freq_manager_1_hex_counter_1_hex_l[3] <= 0;
        freq_manager_1_hex_counter_1_hex_l[4] <= 0;
        freq_manager_1_hex_counter_1_hex_l[5] <= 0;
        freq_manager_1_hex_counter_1_hex_l[6] <= 0;
        freq_manager_1_hex_counter_1_hex_l[7] <= 0;
        freq_manager_1_hex_counter_1_hex_l[8] <= 0;
    end
    else begin
        if ((((freq_manager_1_hex_counter_1_bin_int + freq_manager_1_hex_counter_1_rom_2_dout) > ((10 ** 9) - 1)) && ((freq_manager_1_add == 1'b1) && (freq_manager_1_sub == 1'b0)))) begin
            freq_manager_1_hex_counter_1_bin_int <= ((freq_manager_1_hex_counter_1_bin_int + freq_manager_1_hex_counter_1_rom_2_dout) - (10 ** 9));
        end
        else if (((freq_manager_1_hex_counter_1_bin_int < freq_manager_1_hex_counter_1_rom_2_dout) && ((freq_manager_1_sub == 1'b1) && (freq_manager_1_add == 1'b0)))) begin
            freq_manager_1_hex_counter_1_bin_int <= (($signed({1'b0, freq_manager_1_hex_counter_1_bin_int}) - $signed({1'b0, freq_manager_1_hex_counter_1_rom_2_dout})) + (10 ** 9));
        end
        else begin
            if (((freq_manager_1_add == 1'b1) && (freq_manager_1_sub == 1'b0))) begin
                freq_manager_1_hex_counter_1_bin_int <= (freq_manager_1_hex_counter_1_bin_int + freq_manager_1_hex_counter_1_rom_2_dout);
            end
            else if (((freq_manager_1_sub == 1'b1) && (freq_manager_1_add == 1'b0))) begin
                freq_manager_1_hex_counter_1_bin_int <= (freq_manager_1_hex_counter_1_bin_int - freq_manager_1_hex_counter_1_rom_2_dout);
            end
            else begin
                freq_manager_1_hex_counter_1_bin_int <= freq_manager_1_hex_counter_1_bin_int;
            end
        end
        if (((freq_manager_1_add == 1'b1) && (!freq_manager_1_sub))) begin
            for (digit=0; digit<9; digit=digit+1) begin
                if ((digit > $signed({1'b0, freq_manager_1_dig_incr}))) begin
                    if (freq_manager_1_hex_counter_1_to_add[digit]) begin
                        if ((freq_manager_1_hex_counter_1_hex_l[digit] != 9)) begin
                            freq_manager_1_hex_counter_1_hex_l[digit] <= (freq_manager_1_hex_counter_1_hex_l[digit] + 1);
                        end
                        else begin
                            freq_manager_1_hex_counter_1_hex_l[digit] <= 0;
                        end
                    end
                    else begin
                        freq_manager_1_hex_counter_1_hex_l[digit] <= freq_manager_1_hex_counter_1_hex_l[digit];
                    end
                end
                else if ((digit == $signed({1'b0, freq_manager_1_dig_incr}))) begin
                    if ((freq_manager_1_hex_counter_1_hex_l[freq_manager_1_dig_incr] != 9)) begin
                        freq_manager_1_hex_counter_1_hex_l[freq_manager_1_dig_incr] <= (freq_manager_1_hex_counter_1_hex_l[freq_manager_1_dig_incr] + 1);
                    end
                    else begin
                        freq_manager_1_hex_counter_1_hex_l[freq_manager_1_dig_incr] <= 0;
                    end
                end
            end
        end
        else if (((freq_manager_1_sub == 1'b1) && (!freq_manager_1_add))) begin
            for (digit=0; digit<9; digit=digit+1) begin
                if ((digit > $signed({1'b0, freq_manager_1_dig_incr}))) begin
                    if (freq_manager_1_hex_counter_1_to_subtract[digit]) begin
                        if ((freq_manager_1_hex_counter_1_hex_l[digit] != 0)) begin
                            freq_manager_1_hex_counter_1_hex_l[digit] <= (freq_manager_1_hex_counter_1_hex_l[digit] - 1);
                        end
                        else begin
                            freq_manager_1_hex_counter_1_hex_l[digit] <= 9;
                        end
                    end
                    else begin
                        freq_manager_1_hex_counter_1_hex_l[digit] <= freq_manager_1_hex_counter_1_hex_l[digit];
                    end
                end
                else if ((digit == $signed({1'b0, freq_manager_1_dig_incr}))) begin
                    if ((freq_manager_1_hex_counter_1_hex_l[freq_manager_1_dig_incr] != 0)) begin
                        freq_manager_1_hex_counter_1_hex_l[freq_manager_1_dig_incr] <= (freq_manager_1_hex_counter_1_hex_l[freq_manager_1_dig_incr] - 1);
                    end
                    else begin
                        freq_manager_1_hex_counter_1_hex_l[freq_manager_1_dig_incr] <= 9;
                    end
                end
            end
        end
        else begin
            for (digit=0; digit<9; digit=digit+1) begin
                freq_manager_1_hex_counter_1_hex_l[digit] <= freq_manager_1_hex_counter_1_hex_l[digit];
            end
        end
    end
end


always @(freq_manager_1_dig_incr) begin: WITH_UART_FREQ_MANAGER_1_HEX_COUNTER_1_ROM_2_READ
    case (freq_manager_1_dig_incr)
        0: freq_manager_1_hex_counter_1_rom_2_dout = 1;
        1: freq_manager_1_hex_counter_1_rom_2_dout = 10;
        2: freq_manager_1_hex_counter_1_rom_2_dout = 100;
        3: freq_manager_1_hex_counter_1_rom_2_dout = 1000;
        4: freq_manager_1_hex_counter_1_rom_2_dout = 10000;
        5: freq_manager_1_hex_counter_1_rom_2_dout = 100000;
        6: freq_manager_1_hex_counter_1_rom_2_dout = 1000000;
        7: freq_manager_1_hex_counter_1_rom_2_dout = 10000000;
        default: freq_manager_1_hex_counter_1_rom_2_dout = 100000000;
    endcase
end

// Drives a pulse with period,
// time_step. 
always @(posedge clk) begin: WITH_UART_FREQ_MANAGER_1_HEX_COUNTER_1_CLK_DRIVER
    if (freq_man_reset == 1) begin
        freq_manager_1_hex_counter_1_clk_p_time <= 0;
        freq_manager_1_hex_counter_1_clk_counter <= 00000000;
    end
    else begin
        if ((freq_manager_1_hex_counter_1_clk_counter == 0)) begin
            freq_manager_1_hex_counter_1_clk_p_time <= 1;
            freq_manager_1_hex_counter_1_clk_counter <= (freq_manager_1_hex_counter_1_clk_counter + 1);
        end
        else if (($signed({1'b0, freq_manager_1_hex_counter_1_clk_counter}) >= ($signed({1'b0, freq_manager_1_hex_counter_1_time_step}) - 1))) begin
            freq_manager_1_hex_counter_1_clk_p_time <= 0;
            freq_manager_1_hex_counter_1_clk_counter <= 0;
        end
        else begin
            freq_manager_1_hex_counter_1_clk_p_time <= 0;
            freq_manager_1_hex_counter_1_clk_counter <= (freq_manager_1_hex_counter_1_clk_counter + 1);
        end
    end
end

// Latch values on positive clock edge 
always @(posedge clk) begin: WITH_UART_FREQ_MANAGER_1_HEX_COUNTER_1_LATCH_COUNTS
    if (freq_man_reset == 1) begin
        freq_manager_1_hex_count <= 000000000;
        freq_manager_1_bin_count <= 00000000;
    end
    else begin
        freq_manager_1_hex_count <= freq_manager_1_hex_counter_1_hex_int;
        freq_manager_1_bin_count <= freq_manager_1_hex_counter_1_bin_int;
    end
end

// This module determines whether or not to add/sub certain bits,
// in the case of carry over. First we make sure we don't add/sub all
// the bits lower than increment, then we set the increment bit to add/sub,
// and lastly we perform the logic neccessary to determine if bits greater
// than dig_incr need to be added
// 
// It's sensitivity list is long, this is neccessary as to allow the logic 
// to update to_add when any part of to_add changes, as is the case
// when performing carry logic.
always @(freq_manager_1_dig_incr, freq_manager_1_add, freq_manager_1_sub) begin: WITH_UART_FREQ_MANAGER_1_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_0_0_INNER
    reg digit;
    digit = 0;
    if ((digit == freq_manager_1_dig_incr)) begin
        freq_manager_1_hex_counter_1_to_add[digit] <= 1;
        freq_manager_1_hex_counter_1_to_subtract[digit] <= 1;
    end
    else begin
        freq_manager_1_hex_counter_1_to_add[digit] <= 0;
        freq_manager_1_hex_counter_1_to_subtract[digit] <= 0;
    end
end


always @(freq_manager_1_dig_incr, freq_manager_1_hex_counter_1_hex_l[0], freq_manager_1_hex_counter_1_to_add[0], freq_manager_1_hex_counter_1_to_subtract[0], freq_manager_1_add, freq_manager_1_sub) begin: WITH_UART_FREQ_MANAGER_1_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_1_0_INNER
    if ((1 < freq_manager_1_dig_incr)) begin
        freq_manager_1_hex_counter_1_to_add[1] <= 0;
        freq_manager_1_hex_counter_1_to_subtract[1] <= 0;
    end
    else if ((1 == freq_manager_1_dig_incr)) begin
        freq_manager_1_hex_counter_1_to_add[1] <= 1;
        freq_manager_1_hex_counter_1_to_subtract[1] <= 1;
    end
    else begin
        freq_manager_1_hex_counter_1_to_add[1] <= ((freq_manager_1_hex_counter_1_hex_l[(1 - 1)] == 9) && freq_manager_1_hex_counter_1_to_add[(1 - 1)]);
        freq_manager_1_hex_counter_1_to_subtract[1] <= ((freq_manager_1_hex_counter_1_hex_l[(1 - 1)] == 0) && freq_manager_1_hex_counter_1_to_subtract[(1 - 1)]);
    end
end


always @(freq_manager_1_dig_incr, freq_manager_1_hex_counter_1_hex_l[1], freq_manager_1_hex_counter_1_to_add[1], freq_manager_1_hex_counter_1_to_subtract[1], freq_manager_1_add, freq_manager_1_sub) begin: WITH_UART_FREQ_MANAGER_1_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_2_0_INNER
    if ((2 < freq_manager_1_dig_incr)) begin
        freq_manager_1_hex_counter_1_to_add[2] <= 0;
        freq_manager_1_hex_counter_1_to_subtract[2] <= 0;
    end
    else if ((2 == freq_manager_1_dig_incr)) begin
        freq_manager_1_hex_counter_1_to_add[2] <= 1;
        freq_manager_1_hex_counter_1_to_subtract[2] <= 1;
    end
    else begin
        freq_manager_1_hex_counter_1_to_add[2] <= ((freq_manager_1_hex_counter_1_hex_l[(2 - 1)] == 9) && freq_manager_1_hex_counter_1_to_add[(2 - 1)]);
        freq_manager_1_hex_counter_1_to_subtract[2] <= ((freq_manager_1_hex_counter_1_hex_l[(2 - 1)] == 0) && freq_manager_1_hex_counter_1_to_subtract[(2 - 1)]);
    end
end


always @(freq_manager_1_dig_incr, freq_manager_1_hex_counter_1_hex_l[2], freq_manager_1_hex_counter_1_to_add[2], freq_manager_1_hex_counter_1_to_subtract[2], freq_manager_1_add, freq_manager_1_sub) begin: WITH_UART_FREQ_MANAGER_1_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_3_0_INNER
    if ((3 < freq_manager_1_dig_incr)) begin
        freq_manager_1_hex_counter_1_to_add[3] <= 0;
        freq_manager_1_hex_counter_1_to_subtract[3] <= 0;
    end
    else if ((3 == freq_manager_1_dig_incr)) begin
        freq_manager_1_hex_counter_1_to_add[3] <= 1;
        freq_manager_1_hex_counter_1_to_subtract[3] <= 1;
    end
    else begin
        freq_manager_1_hex_counter_1_to_add[3] <= ((freq_manager_1_hex_counter_1_hex_l[(3 - 1)] == 9) && freq_manager_1_hex_counter_1_to_add[(3 - 1)]);
        freq_manager_1_hex_counter_1_to_subtract[3] <= ((freq_manager_1_hex_counter_1_hex_l[(3 - 1)] == 0) && freq_manager_1_hex_counter_1_to_subtract[(3 - 1)]);
    end
end


always @(freq_manager_1_dig_incr, freq_manager_1_hex_counter_1_hex_l[3], freq_manager_1_hex_counter_1_to_add[3], freq_manager_1_hex_counter_1_to_subtract[3], freq_manager_1_add, freq_manager_1_sub) begin: WITH_UART_FREQ_MANAGER_1_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_4_0_INNER
    if ((4 < freq_manager_1_dig_incr)) begin
        freq_manager_1_hex_counter_1_to_add[4] <= 0;
        freq_manager_1_hex_counter_1_to_subtract[4] <= 0;
    end
    else if ((4 == freq_manager_1_dig_incr)) begin
        freq_manager_1_hex_counter_1_to_add[4] <= 1;
        freq_manager_1_hex_counter_1_to_subtract[4] <= 1;
    end
    else begin
        freq_manager_1_hex_counter_1_to_add[4] <= ((freq_manager_1_hex_counter_1_hex_l[(4 - 1)] == 9) && freq_manager_1_hex_counter_1_to_add[(4 - 1)]);
        freq_manager_1_hex_counter_1_to_subtract[4] <= ((freq_manager_1_hex_counter_1_hex_l[(4 - 1)] == 0) && freq_manager_1_hex_counter_1_to_subtract[(4 - 1)]);
    end
end


always @(freq_manager_1_dig_incr, freq_manager_1_hex_counter_1_hex_l[4], freq_manager_1_hex_counter_1_to_add[4], freq_manager_1_hex_counter_1_to_subtract[4], freq_manager_1_add, freq_manager_1_sub) begin: WITH_UART_FREQ_MANAGER_1_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_5_0_INNER
    if ((5 < freq_manager_1_dig_incr)) begin
        freq_manager_1_hex_counter_1_to_add[5] <= 0;
        freq_manager_1_hex_counter_1_to_subtract[5] <= 0;
    end
    else if ((5 == freq_manager_1_dig_incr)) begin
        freq_manager_1_hex_counter_1_to_add[5] <= 1;
        freq_manager_1_hex_counter_1_to_subtract[5] <= 1;
    end
    else begin
        freq_manager_1_hex_counter_1_to_add[5] <= ((freq_manager_1_hex_counter_1_hex_l[(5 - 1)] == 9) && freq_manager_1_hex_counter_1_to_add[(5 - 1)]);
        freq_manager_1_hex_counter_1_to_subtract[5] <= ((freq_manager_1_hex_counter_1_hex_l[(5 - 1)] == 0) && freq_manager_1_hex_counter_1_to_subtract[(5 - 1)]);
    end
end


always @(freq_manager_1_dig_incr, freq_manager_1_hex_counter_1_hex_l[5], freq_manager_1_hex_counter_1_to_add[5], freq_manager_1_hex_counter_1_to_subtract[5], freq_manager_1_add, freq_manager_1_sub) begin: WITH_UART_FREQ_MANAGER_1_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_6_0_INNER
    if ((6 < freq_manager_1_dig_incr)) begin
        freq_manager_1_hex_counter_1_to_add[6] <= 0;
        freq_manager_1_hex_counter_1_to_subtract[6] <= 0;
    end
    else if ((6 == freq_manager_1_dig_incr)) begin
        freq_manager_1_hex_counter_1_to_add[6] <= 1;
        freq_manager_1_hex_counter_1_to_subtract[6] <= 1;
    end
    else begin
        freq_manager_1_hex_counter_1_to_add[6] <= ((freq_manager_1_hex_counter_1_hex_l[(6 - 1)] == 9) && freq_manager_1_hex_counter_1_to_add[(6 - 1)]);
        freq_manager_1_hex_counter_1_to_subtract[6] <= ((freq_manager_1_hex_counter_1_hex_l[(6 - 1)] == 0) && freq_manager_1_hex_counter_1_to_subtract[(6 - 1)]);
    end
end


always @(freq_manager_1_dig_incr, freq_manager_1_hex_counter_1_hex_l[6], freq_manager_1_hex_counter_1_to_add[6], freq_manager_1_hex_counter_1_to_subtract[6], freq_manager_1_add, freq_manager_1_sub) begin: WITH_UART_FREQ_MANAGER_1_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_7_0_INNER
    if ((7 < freq_manager_1_dig_incr)) begin
        freq_manager_1_hex_counter_1_to_add[7] <= 0;
        freq_manager_1_hex_counter_1_to_subtract[7] <= 0;
    end
    else if ((7 == freq_manager_1_dig_incr)) begin
        freq_manager_1_hex_counter_1_to_add[7] <= 1;
        freq_manager_1_hex_counter_1_to_subtract[7] <= 1;
    end
    else begin
        freq_manager_1_hex_counter_1_to_add[7] <= ((freq_manager_1_hex_counter_1_hex_l[(7 - 1)] == 9) && freq_manager_1_hex_counter_1_to_add[(7 - 1)]);
        freq_manager_1_hex_counter_1_to_subtract[7] <= ((freq_manager_1_hex_counter_1_hex_l[(7 - 1)] == 0) && freq_manager_1_hex_counter_1_to_subtract[(7 - 1)]);
    end
end


always @(freq_manager_1_dig_incr, freq_manager_1_hex_counter_1_hex_l[7], freq_manager_1_hex_counter_1_to_add[7], freq_manager_1_hex_counter_1_to_subtract[7], freq_manager_1_add, freq_manager_1_sub) begin: WITH_UART_FREQ_MANAGER_1_HEX_COUNTER_1_ADDSUBLOGIC_0_LOGIC_8_0_INNER
    if ((8 < freq_manager_1_dig_incr)) begin
        freq_manager_1_hex_counter_1_to_add[8] <= 0;
        freq_manager_1_hex_counter_1_to_subtract[8] <= 0;
    end
    else if ((8 == freq_manager_1_dig_incr)) begin
        freq_manager_1_hex_counter_1_to_add[8] <= 1;
        freq_manager_1_hex_counter_1_to_subtract[8] <= 1;
    end
    else begin
        freq_manager_1_hex_counter_1_to_add[8] <= ((freq_manager_1_hex_counter_1_hex_l[(8 - 1)] == 9) && freq_manager_1_hex_counter_1_to_add[(8 - 1)]);
        freq_manager_1_hex_counter_1_to_subtract[8] <= ((freq_manager_1_hex_counter_1_hex_l[(8 - 1)] == 0) && freq_manager_1_hex_counter_1_to_subtract[(8 - 1)]);
    end
end


initial begin: WITH_UART_FREQ_MANAGER_1_HEX_COUNTER_1_SET_INIT
    integer i;
    # 1;
    for (i=0; i<9; i=i+1) begin
        freq_manager_1_hex_counter_1_to_subtract[i] <= 0;
        freq_manager_1_hex_counter_1_to_add[i] <= 0;
    end
end

// Connect the ram fstep with 
// a value we subtract for allowing for convergence
always @(freq_manager_1_fstep_rambus_dout, freq_manager_1_dig_incr_offset) begin: WITH_UART_FREQ_MANAGER_1_DIGIT_TO_INCREMENT
    if ((freq_manager_1_fstep_rambus_dout >= freq_manager_1_dig_incr_offset)) begin
        freq_manager_1_dig_incr = (freq_manager_1_fstep_rambus_dout - freq_manager_1_dig_incr_offset);
    end
    else begin
        freq_manager_1_dig_incr = 0;
    end
end



assign freq_manager_1_freq_rambus_raddr = freq_manager_1_sched_addr;
assign freq_manager_1_fstep_rambus_raddr = freq_manager_1_sched_addr;
assign freq_manager_1_tstep_rambus_raddr = freq_manager_1_sched_addr;
assign freq_manager_1_holdt_rambus_raddr = freq_manager_1_sched_addr;


always @(negedge clk) begin: WITH_UART_FREQ_MANAGER_1_SCHEDULE_STEPPER
    if (freq_man_reset == 1) begin
        freq_manager_1_sched_addr <= 00;
        freq_manager_1_dig_incr_offset <= 0;
        freq_manager_1_add <= 0;
        freq_manager_1_sub <= 0;
        freq_manager_1_hold_counter <= 00000000;
        freq_manager_1_state <= 2'b00;
    end
    else begin
        case (freq_manager_1_state)
            2'b00: begin
                freq_manager_1_sched_addr <= 0;
                freq_manager_1_dig_incr_offset <= 0;
                freq_manager_1_add <= 0;
                freq_manager_1_sub <= 0;
                freq_manager_1_hold_counter <= 0;
                if ((trigger_mask == 1)) begin
                    freq_manager_1_state <= 2'b01;
                end
                else begin
                    freq_manager_1_state <= 2'b00;
                end
            end
            2'b01: begin
                if ((freq_manager_1_bin_count < $signed({1'b0, freq_manager_1_freq_rambus_dout}))) begin
                    freq_manager_1_add <= 1;
                    freq_manager_1_sub <= 0;
                    if (((freq_manager_1_sub == 1) && (freq_manager_1_dig_incr_offset != 9))) begin
                        freq_manager_1_dig_incr_offset <= (freq_manager_1_dig_incr_offset + 1);
                    end
                    else begin
                        freq_manager_1_dig_incr_offset <= freq_manager_1_dig_incr_offset;
                    end
                end
                else if ((freq_manager_1_bin_count > $signed({1'b0, freq_manager_1_freq_rambus_dout}))) begin
                    freq_manager_1_add <= 0;
                    freq_manager_1_sub <= 1;
                    if (((freq_manager_1_add == 1) && (freq_manager_1_dig_incr_offset != 9))) begin
                        freq_manager_1_dig_incr_offset <= (freq_manager_1_dig_incr_offset + 1);
                    end
                    else begin
                        freq_manager_1_dig_incr_offset <= freq_manager_1_dig_incr_offset;
                    end
                end
                else begin
                    freq_manager_1_add <= 0;
                    freq_manager_1_sub <= 0;
                    freq_manager_1_state <= 2'b10;
                end
            end
            2'b10: begin
                if ((freq_manager_1_hold_counter >= freq_manager_1_holdt_rambus_dout)) begin
                    freq_manager_1_sched_addr <= (freq_manager_1_sched_addr + 1);
                    freq_manager_1_hold_counter <= 0;
                    if (($signed({1'b0, freq_manager_1_sched_addr}) == ($signed({1'b0, sched_len}) - 1))) begin
                        freq_manager_1_state <= 2'b11;
                    end
                    else begin
                        freq_manager_1_state <= 2'b01;
                    end
                end
                else begin
                    freq_manager_1_hold_counter <= (freq_manager_1_hold_counter + 1);
                end
            end
            default: begin
                freq_manager_1_sched_addr <= 0;
                freq_manager_1_dig_incr_offset <= 0;
                freq_manager_1_add <= 0;
                freq_manager_1_sub <= 0;
                freq_manager_1_hold_counter <= 0;
                freq_manager_1_state <= 2'b11;
                if ((trigger_mask == 1)) begin
                    freq_manager_1_state <= 2'b00;
                end
            end
        endcase
    end
end


always @(posedge freq_rambus_clk) begin: WITH_UART_FREQ_MANAGER_1_BUSSEDRAM_4_WRITE
    if (freq_manager_1_bussedram_4_rambus_we) begin
        freq_manager_1_bussedram_4_mem[freq_rambus_waddr] <= freq_rambus_din;
    end
end



assign freq_manager_1_freq_rambus_dout = freq_manager_1_bussedram_4_mem[freq_manager_1_freq_rambus_raddr];


always @(posedge fstep_rambus_clk) begin: WITH_UART_FREQ_MANAGER_1_BUSSEDRAM_5_WRITE
    if (freq_manager_1_bussedram_5_rambus_we) begin
        freq_manager_1_bussedram_5_mem[fstep_rambus_waddr] <= fstep_rambus_din;
    end
end



assign freq_manager_1_fstep_rambus_dout = freq_manager_1_bussedram_5_mem[freq_manager_1_fstep_rambus_raddr];


always @(posedge tstep_rambus_clk) begin: WITH_UART_FREQ_MANAGER_1_BUSSEDRAM_6_WRITE
    if (freq_manager_1_bussedram_6_rambus_we) begin
        freq_manager_1_bussedram_6_mem[tstep_rambus_waddr] <= tstep_rambus_din;
    end
end



assign freq_manager_1_hex_counter_1_time_step = freq_manager_1_bussedram_6_mem[freq_manager_1_tstep_rambus_raddr];


always @(posedge hold_rambus_clk) begin: WITH_UART_FREQ_MANAGER_1_BUSSEDRAM_7_WRITE
    if (freq_manager_1_bussedram_7_rambus_we) begin
        freq_manager_1_bussedram_7_mem[hold_rambus_waddr] <= hold_rambus_din;
    end
end



assign freq_manager_1_holdt_rambus_dout = freq_manager_1_bussedram_7_mem[freq_manager_1_holdt_rambus_raddr];


always @(freq_manager_1_dig_incr) begin: WITH_UART_FREQ_MANAGER_1_ROM_3_READ
    case (freq_manager_1_dig_incr)
        0: freq_manager_1_rom_3_dout = 1;
        1: freq_manager_1_rom_3_dout = 10;
        2: freq_manager_1_rom_3_dout = 100;
        3: freq_manager_1_rom_3_dout = 1000;
        4: freq_manager_1_rom_3_dout = 10000;
        5: freq_manager_1_rom_3_dout = 100000;
        6: freq_manager_1_rom_3_dout = 1000000;
        7: freq_manager_1_rom_3_dout = 10000000;
        default: freq_manager_1_rom_3_dout = 100000000;
    endcase
end



assign hex_freq = freq_manager_1_hex_count;


always @(posedge uart_1_baud) begin: WITH_UART_UART_1_CHECKFORENDBITS
    if (reset == 0) begin
        uart_1_bauds_held_down <= 0;
        uart_1_started <= 0;
    end
    else begin
        if ((!uart_1_started)) begin
            if ((fpga_rx == 0)) begin
                if ((uart_1_bauds_held_down != 4)) begin
                    uart_1_bauds_held_down <= (uart_1_bauds_held_down + 1);
                    uart_1_latch_en <= 0;
                end
                else begin
                    uart_1_bauds_held_down <= 0;
                    uart_1_started <= 1;
                    uart_1_latch_en <= 1;
                end
            end
            else begin
                uart_1_latch_en <= 0;
                uart_1_bauds_held_down <= 0;
            end
        end
        else begin
            if ((uart_1_bits_received == 8)) begin
                uart_1_latch_en <= 0;
            end
            else begin
                uart_1_latch_en <= 1;
            end
            if (((fpga_rx == 1) && (uart_1_bits_received == 8))) begin
                if (($signed({1'b0, uart_1_bauds_held_down}) != (4 + ((1 - 1) * 8)))) begin
                    uart_1_bauds_held_down <= (uart_1_bauds_held_down + 1);
                end
                else begin
                    uart_1_bauds_held_down <= 0;
                    uart_1_started <= 0;
                end
            end
            else if ((uart_1_bits_received == 8)) begin
                uart_1_bauds_held_down <= 0;
            end
        end
    end
end



assign uart_1_slowbaud_rst = (!uart_1_started);
assign uart_1_drdy_int = (!uart_1_started);


always @(posedge uart_1_slowbaud, posedge uart_1_slowbaud_rst) begin: WITH_UART_UART_1_COUNTTHEMBITS
    if (uart_1_slowbaud_rst == 1) begin
        uart_1_bits_received <= 00;
    end
    else begin
        if (uart_1_latch_en) begin
            uart_1_bits_received <= (uart_1_bits_received + 1);
        end
    end
end


always @(posedge clk) begin: WITH_UART_UART_1_DELAY_DRDY
    if (reset == 0) begin
        uart_1_drdy1 <= 1;
        uart_1_drdy2 <= 1;
    end
    else begin
        uart_1_drdy1 <= uart_1_drdy_int;
        uart_1_drdy2 <= uart_1_drdy1;
    end
end


always @(posedge uart_1_drdy_int) begin: WITH_UART_UART_1_LATCH_ON_READY
    if (reset == 0) begin
        rx_data <= 00;
    end
    else begin
        rx_data <= uart_1_rx_data_int;
    end
end


always @(posedge clk) begin: WITH_UART_UART_1_CLKDIV_2_CLOCKDIVIDER
    if ((($signed({1'b0, uart_1_clkdiv_2_counter}) == (156 - 1)) || (uart_1_clkdiv_2_counter == (156 / 2)))) begin
        uart_1_clkdiv_2_clk_new <= (!uart_1_clkdiv_2_clk_new);
    end
    if (($signed({1'b0, uart_1_clkdiv_2_counter}) == (156 - 1))) begin
        uart_1_clkdiv_2_counter <= 0;
    end
    else begin
        uart_1_clkdiv_2_counter <= (uart_1_clkdiv_2_counter + 1);
    end
end



assign uart_1_baud = uart_1_clkdiv_2_clk_new;


always @(posedge uart_1_baud, posedge uart_1_slowbaud_rst) begin: WITH_UART_UART_1_CLKDIV_3_CLOCKDIVIDER
    if (uart_1_slowbaud_rst == 1) begin
        uart_1_clkdiv_3_clk_new <= 0;
        uart_1_clkdiv_3_counter <= 0;
    end
    else begin
        if ((($signed({1'b0, uart_1_clkdiv_3_counter}) == (8 - 1)) || (uart_1_clkdiv_3_counter == (8 / 2)))) begin
            uart_1_clkdiv_3_clk_new <= (!uart_1_clkdiv_3_clk_new);
        end
        if (($signed({1'b0, uart_1_clkdiv_3_counter}) == (8 - 1))) begin
            uart_1_clkdiv_3_counter <= 0;
        end
        else begin
            uart_1_clkdiv_3_counter <= (uart_1_clkdiv_3_counter + 1);
        end
    end
end



assign uart_1_slowbaud = uart_1_clkdiv_3_clk_new;


always @(uart_1_slowbaud, uart_1_latch_en) begin: WITH_UART_UART_1_SHIFTREG_1_WIRING
    integer i;
    for (i=0; i<8; i=i+1) begin
        uart_1_shiftreg_1_clk_int <= (uart_1_slowbaud && uart_1_latch_en);
    end
end


always @(posedge uart_1_shiftreg_1_clk_int) begin: WITH_UART_UART_1_SHIFTREG_1_LATCHER
    integer i;
    reg [0-1:0] loadval;
    if ((1'b0 == 1'b0)) begin
        uart_1_shiftreg_1_latches[0] <= fpga_rx;
        for (i=1; i<8; i=i+1) begin
            uart_1_shiftreg_1_latches[i] <= uart_1_shiftreg_1_latches[(i - 1)];
        end
    end
    else begin
        for (i=0; i<8; i=i+1) begin
            uart_1_shiftreg_1_latches[i] <= loadval[i];
        end
    end
end



assign uart_1_rx_data_int = uart_1_shiftreg_1_par_int;



assign drdy = ((uart_1_drdy1 ^ uart_1_drdy2) & uart_1_drdy1);

// This fsm latches (just after) the dataready positive edge
// signal. The data is guaranteed to be ready then.
always @(posedge clk) begin: WITH_UART_COMMS_ARBITER_0_FSM
    integer i;
    if (comms_arbiter_0_delayed_reset2 == 1) begin
        freq_manager_1_bussedram_4_rambus_we <= 0;
        freq_manager_1_bussedram_5_rambus_we <= 0;
        freq_manager_1_bussedram_6_rambus_we <= 0;
        freq_manager_1_bussedram_7_rambus_we <= 0;
        whichram <= 00;
        state <= 2'b00;
        comms_arbiter_0_latch_counter <= 00;
        biggestblock_l[0] <= 0;
        biggestblock_l[1] <= 0;
        biggestblock_l[2] <= 0;
        biggestblock_l[3] <= 0;
        biggestblock_l[4] <= 0;
        biggestblock_l[5] <= 0;
        biggestblock_l[6] <= 0;
        biggestblock_l[7] <= 0;
        biggestblock_l[8] <= 0;
        biggestblock_l[9] <= 0;
        biggestblock_l[10] <= 0;
        biggestblock_l[11] <= 0;
        biggestblock_l[12] <= 0;
        biggestblock_l[13] <= 0;
        biggestblock_l[14] <= 0;
        biggestblock_l[15] <= 0;
        biggestblock_l[16] <= 0;
        biggestblock_l[17] <= 0;
        biggestblock_l[18] <= 0;
        biggestblock_l[19] <= 0;
        biggestblock_l[20] <= 0;
        biggestblock_l[21] <= 0;
        biggestblock_l[22] <= 0;
        biggestblock_l[23] <= 0;
        biggestblock_l[24] <= 0;
        biggestblock_l[25] <= 0;
        biggestblock_l[26] <= 0;
        biggestblock_l[27] <= 0;
        biggestblock_l[28] <= 0;
        biggestblock_l[29] <= 0;
        biggestblock_l[30] <= 0;
        biggestblock_l[31] <= 0;
        freq_rambus_length <= 00;
        freq_rambus_addr <= 00;
        all_data_received <= 0;
        fstep_rambus_length <= 00;
        fstep_rambus_addr <= 00;
        tstep_rambus_length <= 00;
        tstep_rambus_addr <= 00;
        hold_rambus_length <= 00;
        hold_rambus_addr <= 00;
    end
    else begin
        if (((state == 2'b00) && comms_arbiter_0_drdy_turnedon)) begin
            freq_manager_1_bussedram_4_rambus_we <= 0;
            freq_manager_1_bussedram_5_rambus_we <= 0;
            freq_manager_1_bussedram_6_rambus_we <= 0;
            freq_manager_1_bussedram_7_rambus_we <= 0;
            whichram <= rx_data;
            state <= 2'b01;
        end
        else if (((state == 2'b01) && comms_arbiter_0_drdy_turnedon)) begin
            comms_arbiter_0_latch_counter <= (comms_arbiter_0_latch_counter + 1);
            for (i=0; i<8; i=i+1) begin
                biggestblock_l[(i + (8 * comms_arbiter_0_latch_counter))] <= rx_data[i];
            end
            if ((comms_arbiter_0_latch_counter == 3)) begin
                comms_arbiter_0_latch_counter <= 0;
                state <= 2'b10;
            end
        end
        else if ((state == 2'b10)) begin
            case (whichram)
                'h0: begin
                    freq_manager_1_bussedram_4_rambus_we <= 1;
                    freq_rambus_length <= (freq_rambus_length + 1);
                    freq_rambus_addr <= (freq_rambus_addr + 1);
                    all_data_received <= 0;
                end
                'h1: begin
                    freq_manager_1_bussedram_5_rambus_we <= 1;
                    fstep_rambus_length <= (fstep_rambus_length + 1);
                    fstep_rambus_addr <= (fstep_rambus_addr + 1);
                    all_data_received <= 0;
                end
                'h2: begin
                    freq_manager_1_bussedram_6_rambus_we <= 1;
                    tstep_rambus_length <= (tstep_rambus_length + 1);
                    tstep_rambus_addr <= (tstep_rambus_addr + 1);
                    all_data_received <= 0;
                end
                'h3: begin
                    freq_manager_1_bussedram_7_rambus_we <= 1;
                    hold_rambus_length <= (hold_rambus_length + 1);
                    hold_rambus_addr <= (hold_rambus_addr + 1);
                    all_data_received <= 0;
                end
                'h16: begin
                    freq_manager_1_bussedram_4_rambus_we <= 0;
                    freq_manager_1_bussedram_5_rambus_we <= 0;
                    freq_manager_1_bussedram_6_rambus_we <= 0;
                    freq_manager_1_bussedram_7_rambus_we <= 0;
                    all_data_received <= 1;
                end
                default: begin
                    freq_manager_1_bussedram_4_rambus_we <= 0;
                    freq_manager_1_bussedram_5_rambus_we <= 0;
                    freq_manager_1_bussedram_6_rambus_we <= 0;
                    freq_manager_1_bussedram_7_rambus_we <= 0;
                end
            endcase
            state <= 2'b00;
        end
        else begin
            freq_manager_1_bussedram_4_rambus_we <= 0;
            freq_manager_1_bussedram_5_rambus_we <= 0;
            freq_manager_1_bussedram_6_rambus_we <= 0;
            freq_manager_1_bussedram_7_rambus_we <= 0;
        end
    end
end

// This is a little block for determining whether 
// drdy has transitioned in the last clock cycle.
// It effectively turns the drdy step function into 
// a hat function.
always @(posedge clk) begin: WITH_UART_COMMS_ARBITER_0_DRDY_MONITOR
    if (reset == 0) begin
        freq_man_reset <= 0;
        comms_arbiter_0_drdy_old <= 1;
        comms_arbiter_0_drdy_turnedon <= 0;
    end
    else begin
        freq_man_reset <= comms_arbiter_0_drdy_turnedon;
        comms_arbiter_0_drdy_old <= drdy;
        if (((drdy != comms_arbiter_0_drdy_old) && (comms_arbiter_0_drdy_old == 0))) begin
            comms_arbiter_0_drdy_turnedon <= 1;
        end
        else begin
            comms_arbiter_0_drdy_turnedon <= 0;
        end
    end
end


always @(posedge clk) begin: WITH_UART_COMMS_ARBITER_0_RESET_DELAYER
    comms_arbiter_0_delayed_reset1 <= reset;
    comms_arbiter_0_delayed_reset2 <= comms_arbiter_0_delayed_reset1;
end

// Just connect the notclock signal for passing into the RAMs  

assign notclock = (!clk);

// Combinatorial logic here to determine
// the schedule length as the smallest amount of data points stuck into the RAMs
always @(freq_rambus_length, fstep_rambus_length, tstep_rambus_length, hold_rambus_length) begin: WITH_UART_DETERMINE_SCHED_LEN
    if (((freq_rambus_length < fstep_rambus_length) && (freq_rambus_length < tstep_rambus_length) && (freq_rambus_length < hold_rambus_length))) begin
        sched_len = freq_rambus_length;
    end
    else if (((tstep_rambus_length < fstep_rambus_length) && (tstep_rambus_length < freq_rambus_length) && (tstep_rambus_length < hold_rambus_length))) begin
        sched_len = tstep_rambus_length;
    end
    else if (((hold_rambus_length < fstep_rambus_length) && (hold_rambus_length < freq_rambus_length) && (hold_rambus_length < tstep_rambus_length))) begin
        sched_len = hold_rambus_length;
    end
    else begin
        sched_len = fstep_rambus_length;
    end
end

// Connect basic signals of the RAMS: data in and data_out and clock

assign freq_rambus_din = biggestblock[32-1:0];
assign fstep_rambus_din = biggestblock[32-1:0];
assign tstep_rambus_din = biggestblock[32-1:0];
assign hold_rambus_din = biggestblock[32-1:0];
assign freq_rambus_clk = notclock;
assign fstep_rambus_clk = notclock;
assign tstep_rambus_clk = notclock;
assign hold_rambus_clk = notclock;
assign freq_rambus_waddr = freq_rambus_addr;
assign fstep_rambus_waddr = fstep_rambus_addr;
assign tstep_rambus_waddr = tstep_rambus_addr;
assign hold_rambus_waddr = hold_rambus_addr;



assign trigger_mask = (trigger && all_data_received);


always @(led2_i, all_data_received, whichram) begin: WITH_UART_LED_WIRING
    integer i;
    for (i=0; i<9; i=i+1) begin
        led2 = led2_i;
    end
    led2_l[8] = all_data_received;
    for (i=0; i<8; i=i+1) begin
        led2_l[i] = whichram[i];
    end
end



assign amphenol = pts_controller_1_amphenol_int;
assign pts_controller_1_amphenol_l[49] = 0;
assign pts_controller_1_amphenol_l[48] = 1;
assign pts_controller_1_amphenol_l[41] = (!1'b1);
assign pts_controller_1_amphenol_l[20] = 0;
assign pts_controller_1_amphenol_l[21] = 0;
assign pts_controller_1_amphenol_l[22] = 1;
assign pts_controller_1_amphenol_l[23] = 1;
assign pts_controller_1_amphenol_l[24] = 1;
assign pts_controller_1_amphenol_l[45] = 1;
assign pts_controller_1_amphenol_l[46] = 1;
assign pts_controller_1_amphenol_l[43] = (!hex_freq[33]);
assign pts_controller_1_amphenol_l[42] = (!hex_freq[32]);
assign pts_controller_1_amphenol_l[40] = (!hex_freq[31]);
assign pts_controller_1_amphenol_l[39] = (!hex_freq[30]);
assign pts_controller_1_amphenol_l[15] = (!hex_freq[29]);
assign pts_controller_1_amphenol_l[14] = (!hex_freq[28]);
assign pts_controller_1_amphenol_l[19] = (!hex_freq[27]);
assign pts_controller_1_amphenol_l[18] = (!hex_freq[26]);
assign pts_controller_1_amphenol_l[17] = (!hex_freq[25]);
assign pts_controller_1_amphenol_l[16] = (!hex_freq[24]);
assign pts_controller_1_amphenol_l[26] = (!hex_freq[23]);
assign pts_controller_1_amphenol_l[25] = (!hex_freq[22]);
assign pts_controller_1_amphenol_l[1] = (!hex_freq[21]);
assign pts_controller_1_amphenol_l[0] = (!hex_freq[20]);
assign pts_controller_1_amphenol_l[28] = (!hex_freq[19]);
assign pts_controller_1_amphenol_l[27] = (!hex_freq[18]);
assign pts_controller_1_amphenol_l[3] = (!hex_freq[17]);
assign pts_controller_1_amphenol_l[2] = (!hex_freq[16]);
assign pts_controller_1_amphenol_l[30] = (!hex_freq[15]);
assign pts_controller_1_amphenol_l[29] = (!hex_freq[14]);
assign pts_controller_1_amphenol_l[5] = (!hex_freq[13]);
assign pts_controller_1_amphenol_l[4] = (!hex_freq[12]);
assign pts_controller_1_amphenol_l[32] = (!hex_freq[11]);
assign pts_controller_1_amphenol_l[31] = (!hex_freq[10]);
assign pts_controller_1_amphenol_l[7] = (!hex_freq[9]);
assign pts_controller_1_amphenol_l[6] = (!hex_freq[8]);
assign pts_controller_1_amphenol_l[34] = (!hex_freq[7]);
assign pts_controller_1_amphenol_l[33] = (!hex_freq[6]);
assign pts_controller_1_amphenol_l[9] = (!hex_freq[5]);
assign pts_controller_1_amphenol_l[8] = (!hex_freq[4]);
assign pts_controller_1_amphenol_l[36] = (!hex_freq[3]);
assign pts_controller_1_amphenol_l[35] = (!hex_freq[2]);
assign pts_controller_1_amphenol_l[11] = (!hex_freq[1]);
assign pts_controller_1_amphenol_l[10] = (!hex_freq[0]);
assign pts_controller_1_amphenol_l[38] = 0;
assign pts_controller_1_amphenol_l[37] = 1;
assign pts_controller_1_amphenol_l[13] = 1;
assign pts_controller_1_amphenol_l[12] = 1;

endmodule
